# C ++ Notes

!!!Note this is a note

## Links

[Reference](https://en.cppreference.com/w/)
[Try this tutorial](https://msdn.microsoft.com/en-us/library/bb384843.aspx)
[Dr. GUI](https://msdn.microsoft.com/en-us/library/aa302304.aspx)
[C Language Reference | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/c-language/c-language-reference?view=vs-2017)
[C++ Language Reference | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=vs-2019)

[Good General reference](http://www.cplusplus.com/)

 - [Tutorial](http://www.cplusplus.com/doc/tutorial/)
 
[C++ FAQ](https://isocpp.org/wiki/faq)

[C++ Data Types - Tutorialspoint](https://www.tutorialspoint.com/cplusplus/cpp_data_types.htm)


## Archetypical Program


```c++
// this is a format
#include <iostream>

/* Another comment format */

using namespace std;

int main(int argc, char* argv[]){
    cout << "Groovy Baby!" << "\n";
    
    }


```


header files no longer contain *.h




## Multiple Files

### Initial Prototype

```c++
//#main.cpp

#include <iostream.h>
using namespace std;

void greetings(); //program func prototype

int main(){
   greetings();
   return 0;

}

void greetings(){ //program function definition
   cout << "Hello World!" << endl;
   return;
}
```

### Brokenout to multiple files

To separate files:

#### header

```c++
//#greet.h
#ifndef GREET_H
#define GREET_H
//if not defined, define GREET_H- prevents multiple definitions
//only done in the header file.

#include <iostream.h>
using namespace std;

//include the prototype
void greetings(); //program func prototype

#endif
```

Header file includes:

- prototypes
- global constants
- template code
- struct defs
- class defs
- ifndef and def

do not `#include` a *.cpp, only `#include *.h`

#### Implementation

```c++
//#greet.cpp
#include "greet.h" //use quotes for files found in cur dir


void greetings(){ //program function definition
   cout << "Hello World!" << endl;
   return;
}
```

`#include "greet.h" //use quotes for files found in cur dir` includes the header file for itself which releases the necessity of ordering the files in a particular order.

`#include <iostream.h>` is in the header, so not required for being included into **greet.cpp**

#### Main Revised

```c++
//#main.cpp

#include <iostream.h>
//add the include
#include "greet.h" //use quotes for files found in cur dir

using namespace std;

//// void greetings(); //program func prototype
//=> moves to .h

int main(){
   greetings();
   return 0;

}

//// void greetings(){ //program function definition
////    cout << "Hello World!" << endl;
////    return;
//// }
```
## Compilation

Sinle File:
`g++ -W -Wall -s -pendantic-errors proq.cpp -o my_proq`

To multiple files:
`g++ -W -Wall -s -pendantic-errors treeFarm.cpp treeFarmFunctions.cpp -o my_proq`
`g++ -W -Wall -s -pendantic-errors *.cpp  -o my_proq`

### Pragmas:

[Pragma directives and the __pragma keyword | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2017)

The Microsoft C and C++ compilers recognize the following pragmas:
Table 1



- alloc_text
- auto_inline
- bss_seg
- check_stack
- code_seg
- comment
- component
- conform 1
- const_seg
- data_seg
- deprecated
- detect_mismatch
- fenv_access
- float_control
- fp_contract
- function
- hdrstop
- include_alias
- init_seg 1
- inline_depth
- inline_recursion
- intrinsic
- loop 1
- make_public
- managed
- message
- omp
- once
- optimize
- pack
- pointers_to_members 1
- pop_macro
- push_macro
- region, endregion
- runtime_checks
- section
- setlocale
- strict_gs_check
- unmanaged
- vtordisp 1
- warning

### Compiler Pre-Defined Macros

[Predefined macros | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017)
Standard predefined macros


The compiler supports these predefined macros specified by the ISO C99 and ISO C++17 standards.

    __cplusplus Defined as an integer literal value when the translation unit is compiled as C++. Otherwise, undefined.

    __DATE__ The compilation date of the current source file. The date is a constant length string literal of the form Mmm dd yyyy. The month name Mmm is the same as the abbreviated month name generated by the C Runtime Library (CRT) asctime function. The first character of date dd is a space if the value is less than 10. This macro is always defined.

    __FILE__ The name of the current source file. __FILE__ expands to a character string literal. To ensure that the full path to the file is displayed, use /FC (Full Path of Source Code File in Diagnostics). This macro is always defined.

    __LINE__ Defined as the integer line number in the current source file. The value of the __LINE__ macro can be changed by using a #line directive. This macro is always defined.

    __STDC__ Defined as 1 only when compiled as C and if the /Za compiler option is specified. Otherwise, undefined.

    __STDC_HOSTED__ Defined as 1 if the implementation is a hosted implementation, one that supports the entire required standard library. Otherwise, defined as 0.

    __STDCPP_THREADS__ Defined as 1 if and only if a program can have more than one thread of execution, and compiled as C++. Otherwise, undefined.

    __TIME__ The time of translation of the preprocessed translation unit. The time is a character string literal of the form hh:mm:ss, the same as the time returned by the CRT asctime function. This macro is always defined.

(Microsoft-specific predefined macros)[https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017#microsoft-specific-predefined-macros]

### Preprocessor operators

[Preprocessor operators | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=vs-2017)
 
[See also](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=vs-2017#see-also)
 
 Four preprocessor-specific operators are used in the context of the `#define` directive The stringizing, charizing, and token-pasting operators are discussed in the next three sections. For information on the `defined` operator, see [The #if, #elif, #else, and #endif directives](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2017).
 
 
 `#` [Stringizing operator (#)](https://docs.microsoft.com/en-us/cpp/preprocessor/stringizing-operator-hash?view=vs-2017) 
  - Causes the corresponding actual argument to be enclosed in double quotation marks
 
 `#@` [Charizing operator (#@)](https://docs.microsoft.com/en-us/cpp/preprocessor/charizing-operator-hash-at?view=vs-2017)
 
  - Causes the corresponding argument to be enclosed in single quotation marks and to be treated as a character (Microsoft-specific)
 
 `##` [Token-pasting operator (##)](https://docs.microsoft.com/en-us/cpp/preprocessor/token-pasting-operator-hash-hash?view=vs-2017)
  - allows tokens used as actual arguments to be concatenated to form other tokens
 
 `defined` [defined operator](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2017)
 
 Simplifies the writing of compound expressions in certain macro directives

### Preprocessor directives

[Preprocessor directives | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2017)

The preprocessor recognizes the following directives:


- #define 
[#define](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-define-directive-c-cpp?view=vs-2019) 

- #error
- #import
- #undef
- #elif
- #if
- #include
- #using
- #else
- #ifdef
- #line
- #endif
- #ifndef
- #pragma

[Preprocessor directives | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2019)


[#error](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-error-directive-c-cpp?view=vs-2019) 
[#import](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp?view=vs-2019) 
[#undef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-undef-directive-c-cpp?view=vs-2019) 
[#elif](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019) 
[#if](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019)
[#include](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=vs-2019)
[#using](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-using-directive-cpp?view=vs-2019) 
[#else](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019) 
[#ifdef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=vs-2019) 
[#line](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-line-directive-c-cpp?view=vs-2019) 
[#endif](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019)
[#ifndef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=vs-2019) 
[#pragma](https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019)


___

## Standard Libraries

___

- [Language Support
   - *\<cstddef\>*
   - *\<cstdlib\>*
   - *\<version\>*
   - *\<limits\>*
   - *\<climits\>*
   - *\<cfloat\>*
   - *\<cstdint\>*
   - *\<new\>*
   - *\<typeinfo\>*
   - *\<source_location\>*
   - *\<exception\>*
   - *\<initializer_list\>*
   - *\<compare\>*
   - *\<coroutine\>*
   - *\<csignal\>*
   - *\<csetjmp\>*
   - *\<cstdarg\>*
- Concepts
   - *\<concepts\>*
- Diagnostics
   - *\<stdexcept\>*
   - *\<cassert\>*
   - *\<cerrno\>*
   - *\<system_error\>*
- General utilities
   - *\<utility\>*
   - *\<memory\>*
   - *\<memory_resource\>*
   - *\<scoped_allocator\>*
   - *\<bitset\>*
   - *\<tuple\>*
   - *\<optional\>*
   - *\<any\>*
   - *\<variant\>*
   - *\<type_traits\>*
   - *\<ratio\>*
   - *\<chrono\>*
   - *\<typeindex\>*
   - *\<functional\>*
   - *\<stacktrace\>*
   - *\<ctime\>*
- Strings
   - *\<string\>*
   - *\<string_view\>*
   - *\<cstring\>*
   - *\<charconv\>*
   - *\<format\>*
   - *\<cctype\>*
   - *\<cwctype\>*
   - *\<cwchar\>*
   - *\<cuchar\>*
- Localization
   - *\<locale\>*
   - *\<codecvt\>*
   - *\<clocale\>*
- Containers
   - *\<span\>*
   - *\<array\>*
   - *\<vector\>*
   - *\<deque\>*
   - *\<forward_list\>*
   - *\<list\>*
   - *\<map\>*
   - *\<set\>*
   - *\<queue\>*
   - *\<unordered_map\>*
   - *\<unordered_set\>*
   - *\<stack\>*
- Iterators
   - *\<iterator\>*
- Ranges
   - *\<ranges\>*
- Algorithms
   - *\<algorithm\>*
   - *\<execution\>*
- Numerics
   - *\<complex\>*
   - *\<random\>*
   - *\<valarray\>*
   - *\<numeric\>*
   - *\<bit\>*
   - *\<numbers\>*
   - *\<cfenv\>*
   - *\<cmath\>*
- Input/Output
   - *\<iosfwd\>*
   - *\<ios\>*
   - *\<iomanip\>*
   - *\<streambuf\>*
   - *\<istream\>*
   - *\<ostream\>*
   - *\<iostream\>*
   - *\<sstream\>*
   - *\<fstream\>*
   - *\<syncstream\>*
   - *\<cstdio\>*
   - *\<cinttypes\>*
   - *\<strstream\>*
- Regular expressions
   - *\<regex\>*
- Filesystem support
   - *\<filesystem\>*
- Thread support
   - *\<thread\>*
   - *\<atomic\>*
   - *\<mutex\>*
   - *\<shared_mutex\>*
   - *\<condition_variable\>*
   - *\<future\>*
   - *\<stop_token\>*
   - *\<semaphore\>*
   - *\<latch\>*
   - *\<barrier\>*
- C compatibility
   - *\<ciso646\>*
   - *\<cstdalign\>*
   - *\<cstdbool\>*
   - *\<ccomplex\>*
   - *\<ctgmath\>*
   - *\<stdatomic.h\>*

s
Atomics and threading library

<atomic>
    Atomic (header)

<condition_variable>
    Condition variable (header)

<future>
    Future (header)

<mutex>
    Mutex (header)

<thread>
    Thread (header)

 

### C Library
The elements of the C language library are also included as a subset of the C++ Standard library. These cover many aspects, from general utility functions and macros to input/output functions and dynamic memory management functions:

- *\<cassert\>*- **(assert.h)** - *C Diagnostics Library (header)*
- *\<cctype\>*- **(ctype.h)** - *Character handling functions (header)*
- *\<cerrno\>*- **(errno.h)** - *C Errors (header)*
- *\<cfenv\>*- **(fenv.h)** - *Floating-point environment (header)*
- *\<cfloat\>*- **(float.h)** - *Characteristics of floating-point types (header)*
- *\<cinttypes\>*- **(inttypes.h)** - *C integer types (header)*
- *\<ciso646\>*- **(iso646.h)** - *ISO 646 Alternative operator spellings (header)*
- *\<climits\>*- **(limits.h)** - *Sizes of integral types (header)*
- *\<clocale\>*- **(locale.h)** - *C localization library (header)*
- *\<cmath\>*- **(math.h)** - *C numerics library (header)*
- *\<csetjmp\>*- **(setjmp.h)** - *Non local jumps (header)*
- *\<csignal\>*- **(signal.h)** - *C library to handle signals (header)*
- *\<cstdarg\>*- **(stdarg.h)** - *Variable arguments handling (header)*
- *\<cstdbool\>*- **(stdbool.h)** - *Boolean type (header)*
- *\<cstddef\>*- **(stddef.h)** - *C Standard definitions (header)*
- *\<cstdint\>*- **(stdint.h)** - *Integer types (header)*
- *\<cstdio\>*- **(stdio.h)** - *C library to perform Input/Output operations (header)*
- *\<cstdlib\>*- **(stdlib.h)** - *C Standard General Utilities Library (header)*
- *\<cstring\>*- **(string.h)** - *C Strings (header)*
- *\<ctgmath\>*- **(tgmath.h)** - *Type-generic math (header)*
- *\<ctime\>*- **(time.h)** - *C Time Library (header)*
- *\<cuchar\>*- **(uchar.h)** - *Unicode characters (header)*
- *\<cwchar\>*- **(wchar.h)** - *Wide characters (header)*
- *\<cwctype\>*- **(wctype.h)** - *Wide character type (header)*


- *\<algorithm\>*- Standard Template Library: Algorithms (library )
- *\<chrono\>*- Time library (header)
- *\<codecvt\>*- Unicode conversion facets (header)
- *\<complex\>*- Complex numbers library (header)
- *\<exception\>*- Standard exceptions (header)
- *\<functional\>*- Function objects (header)
- *\<initializer_list\>*- Initializer list (header)
- *\<iterator\>*- Iterator definitions (header)
- *\<limits\>*- Numeric limits (header)
- *\<locale\>*- Localization library (header)
- *\<memory\>*- Memory elements (header)
- *\<new\>*- Dynamic memory (header)
- *\<numeric\>*- Generalized numeric operations (header)
- *\<random\>*- Random (header)
- *\<ratio\>*- Ratio header (header)
- *\<regex\>*- Regular Expressions (header)
- *\<stdexcept\>*- Exception classes (header)
- *\<string\>*- Strings (header)
- *\<system_error\>*- System errors (header)
- *\<tuple\>*- Tuple library (header)
- *\<typeindex\>*- Type index (header)
- *\<typeinfo\>*- Type information (header)
- *\<type_traits\>*- type_traits (header)
- *\<utility\>*- Utility components (header)
- *\<valarray\>*- Library for arrays of numeric values (header)

**Containers**

- *\<array\>* - **Array header**

- *\<bitset\>* - **Bitset header**

- *\<deque\>* - **Deque header**

- *\<forward_list\>* - **Forward list**

- *\<list\>* - **List header**

- *\<map\>* - **Map header**

- *\<queue\>* - **Queue header**

- *\<set\>* - **Set header**

- *\<stack\>* - **Stack header**

- *\<unordered_map\>* - **Unordered map header**

- *\<unordered_set\>* - **Unordered set header**

- *\<vector\>* - **Vector header**

## Archetypical Program


```c++
// this is a format
#include <iostream>

/* Another comment format */

using namespace std;

int main(){
    cout << "Groovy Baby!" << "\n";
    
    return 0;
    }

int main()
{
    int x;        // This is a C++ style comment

    // Each comment line is preceded by slashes
    // This is another comment line

    /* C++ also supports C-Style comments */

    return 0;
}

```

header files no longer contain *.h

```c++
#include <cstdlib>    // was *\<stdlib.h\>*
#include <cstring>    // was *\<string.h\>*
                      // char* functions from C
#include <string>     // C++ string class
```


## include
!!!Warning:  Note: If you are using the Microsoft Visual C++ IDE, you will notice that by default, all source files start as follows:
      `#include "stdafx.h"`
    In a VC++ project, by default, every source file should start with this line, and your own include files must follow this. If you place your own include file before `stdafx.h`, they will appear to have no effect and you will get all kinds of compilation errors. This situation involves the concept of precompiled header files, which is outside the scope of this book. Consult the Microsoft documentation on precompiled header files to learn the details.



## C++ Operators

You can also just use keywords instead of chars to make more readable program

| Operator    | Operator Keyword | Description                     |
| ----------- | ---------------- | ------------------------------- |
| Logical    |                  |                                 |
| &&          | and              | logical AND                     |
| \|\|        | or               | logical OR                      |
| !           | not              | logical NOT                     |
| Inequality |                  |                                 |
| !=          | not_eq           | inequality                      |
| Bitwise    |                  |                                 |
| &           | bitand           | bitwise AND                     |
| \|          | bitor            | bitwise OR                      |
| ^           | xor              | bitwise exclusive OR            |
| ~           | compl            | bitwise complement              |
| Bitwise Op  |                  |                                 |
| &=          | and_eq           | bitwise AND assignment          |
| \|=         | or_eq            | bitwise inclusive OR assignment |
| ^=          | xor_eq           | bitwise exclusive OR assignment |


```c++
// Program to demonstrate "and" operator keyword
//
// Some compilers require inclusion of special header files

#include    <iostream>
#include    <iso646.h>        // Required for Visual C++ 6.0
using namespace std;

int main()
{
    int x = 8;
    int y;

    cout << "Enter an integer: ";
    cin >> y;

    if ( (x > 0) && (y > 0) )   cout << "Both greater than 0 \n";

    if ( (x > 0) and (y > 0 ) ) cout << "Same thing \n";

    return 0;
}
```

### ISO 646 Alternative operator spellings

<ciso646> (iso646.h)

This header defines eleven macro constants with alternative spellings for those C++ operators not supported by the ISO646 standard character set:

- **macro** :  - `operator`
- **and** :  - `&&`
- **and_eq** :  - `&=`
- **bitand** :  - `&`
- **bitor** :  - `|`
- **compl** :  - `~`
- **not** :  - `!`
- **not_eq** :  - `!=`
- **or** :  - `||`
- **or_eq** :  - `|=`
- **xor** :  - `^`
- **xor_eq** :  - `^=`

In C++, reserved words exist with the same names as these macros and are treated as aliases of their respective operator. Therefore the inclusion of this header has no effect in C++, and is not necessary in order to use the alternative names.


### Operator Precedence

[Operator Pref](http://en.cppreference.com/w/cpp/language/operator_precedence)


### C numerics library

[<cmath> (math.h) - C++ Reference](https://www.cplusplus.com/reference/cmath/)

<cmath> (math.h)
Header <cmath> declares a set of functions to compute common mathematical operations and transformations:

Functions

Trigonometric functions

- `cos` - Compute cosine (function )
- `sin` - Compute sine (function )
- `tan` - Compute tangent (function )
- `acos` - Compute arc cosine (function )
- `asin` - Compute arc sine (function )
- `atan` - Compute arc tangent (function )
- `atan2` - Compute arc tangent with two parameters (function )

Hyperbolic functions

- `cosh` - Compute hyperbolic cosine (function )
- `sinh` - Compute hyperbolic sine (function )
- `tanh` - Compute hyperbolic tangent (function )
- `acosh` - Compute area hyperbolic cosine (function )
- `asinh` - Compute area hyperbolic sine (function )
- `atanh` - Compute area hyperbolic tangent (function )

Exponential and logarithmic functions

- `exp` - Compute exponential function (function )
- `frexp` - Get significand and exponent (function )
- `ldexp` - Generate value from significand and exponent (function )
- `log` - Compute natural logarithm (function )
- `log10` - Compute common logarithm (function )
- `modf` - Break into fractional and integral parts (function )
- `exp2` - Compute binary exponential function (function )
- `expm1` - Compute exponential minus one (function )
- `ilogb` - Integer binary logarithm (function )
- `log1p` - Compute logarithm plus one (function )
- `log2` - Compute binary logarithm (function )
- `logb` - Compute floating-point base logarithm (function )
- `scalbn` - Scale significand using floating-point base exponent (function )
- `scalbln` - Scale significand using floating-point base exponent (long) (function )

Power functions

- `pow` - Raise to power (function )
- `sqrt` - Compute square root (function )
- `cbrt` - Compute cubic root (function )
- `hypot` - Compute hypotenuse (function )

Error and gamma functions

- `erf` - Compute error function (function )
- `erfc` - Compute complementary error function (function )
- `tgamma` - Compute gamma function (function )
- `lgamma` - Compute log-gamma function (function )

Rounding and remainder functions

- `ceil` - Round up value (function )
- `floor` - Round down value (function )
- `fmod` - Compute remainder of division (function )
- `trunc` - Truncate value (function )
- `round` - Round to nearest (function )
- `lround` - Round to nearest and cast to long integer (function )
- `llround` - Round to nearest and cast to long long integer (function )
- `rint` - Round to integral value (function )
- `lrint` - Round and cast to long integer (function )
- `llrint` - Round and cast to long long integer (function )
- `nearbyint` - Round to nearby integral value (function )
- `remainder` - Compute remainder (IEC 60559) (function )
- `remquo` - Compute remainder and quotient (function )

Floating-point manipulation functions

- `copysign` - Copy sign (function )
- `nan` - Generate quiet NaN (function )
- `nextafter` - Next representable value (function )
- `nexttoward` - Next representable value toward precise value (function )

Minimum, maximum, difference functions

- `fdim` - Positive difference (function )
- `fmax` - Maximum value (function )
- `fmin` - Minimum value (function )

Other functions

- `fabs` - Compute absolute value (function )
- `abs` - Compute absolute value (function )
- `fma` - Multiply-add (function )

Macros / Functions
These are implemented as macros in C and as functions in C++:
Classification macro / functions

- `fpclassify` - Classify floating-point value (macro/function )
- `isfinite` - Is finite value (macro )
- `isinf` - Is infinity (macro/function )
- `isnan` - Is Not-A-Number (macro/function )
- `isnormal` - Is normal (macro/function )
- `signbit` - Sign bit (macro/function )

Comparison macro / functions

- `isgreater` - Is greater (macro )
- `isgreaterequal` - Is greater or equal (macro )
- `isless` - Is less (macro )
- `islessequal` - Is less or equal (macro )
- `islessgreater` - Is less or greater (macro )
- `isunordered` - Is unordered (macro )

Macro constants

- `math_errhandling` - Error handling (macro )
- `INFINITY` - Infinity (constant )
- `NAN` - Not-A-Number (constant )
- `HUGE_VAL` - Huge value (constant )
- `HUGE_VALF` - Huge float value
- `HUGE_VALL` - Huge long double value (constant )

This header also defines the following macro constants (since C99/C++11):
macro	type	description
`MATH_ERRNO`
`MATH_ERREXCEPT`	int	Bitmask value with the possible values math_errhandling can take.
`FP_FAST_FMA`
`FP_FAST_FMAF`: **int** - Each, if defined, identifies for which type fma is at least as efficient as x*y+z.
`FP_INFINITE`
`FP_NAN`
`FP_NORMAL`
`FP_SUBNORMAL`: **int** - The possible values returned by fpclassify.
`FP_ILOGB0`: **int** - Special values the ilogb function may return.

Types

- `double_t` - Floating-point type (type )
- `float_t` - Floating-point type (type )


## Stdin and Std Out

`<<` insertion operator 
`>>` extraction operator

These can be chained.

C++ uses the standard input stream cin and the standard output stream cout

`#include <cstdlib>`
`#include <iostream>`


An example of stdin and out vs. C.

```c++
#include    <iostream>    // Header file defining standard C++ I/O 
#include    <stdio.h>        // Old C language header now deprecated
using namespace std;
int main()
{
    int x = 0;

    /* The old C way */

    printf( "Please enter an integer: " );
    scanf( "%d", &x );
    printf( "You entered %d \n", x );

    // The C++ way

    cout << "Please enter an integer: ";
    cin >> x;
    cout << "You entered " << x << endl;
    cout << "x plus 2 is ";
    cout << x + 2 << endl;
    
    return 0;
}
```

```c++
// Program Input:    10    20
//        30
//
// Program Output:    You entered: 10 20 30

#include    <iostream>
using namespace std;
int main()
{
    int x, y, z;

    cout << "enter 3 integers: ";
    cin >> x >> y >> z;        // whitespace delimits numeric input objects

    cout << "You entered: " << x << " " << y << " " << z << endl;

    return 0;
}
```

### Stream Manipulators

`#include <iomanip>`

Stream manipulators may be parameterized or non-parameterized
Must include the header file iomanip to use parameterized manipulators

showpoint
noshowpoint
setw(n)
boolalpha
setprecision(3) 
scientific
fixed


```c++
#include    <iostream>
#include    <iomanip>        // Required for parameterized manipulators
#define    dbln    "\n\n"    // Symbolic constant prints 2 newlines

using    namespace    std;

int main()
{
    float v = 2.19512567f;
    float c = 4.f;
    
    cout << v << endl;
    cout << c << dbln;

    cout << showpoint << v << endl;    // showpoint forces dec & 0's
    cout << c << dbln;

    cout << noshowpoint << c << dbln;    // reinstate default

    cout << setw(10) << v << endl;    // set field width to 10
    cout << c << dbln;

    return 0;
}

// Program to illustrate stream manipulators
//
// Program Output:    2.19513
//        4
//
//        2.19513
//        4.00000
//
//        4
//
//           2.19513
//        4



#include    <iostream>
#include    <iomanip>
#define    dbln    "\n\n"
using    namespace    std;

int main()
{
    bool    b = true;
    float    f = 3.14159f;

    cout << b << endl;
    cout << boolalpha << b << dbln;

    cout << f << endl;
    cout << scientific << setprecision(3) << f << endl;
    cout << fixed << f << dbln;

    return 0;
}

// Program to demonstrate stream manipulators
//
// Program Output:    1
//        true
//
//        3.14159
//        3.142e+000
//        3.142
```

## Types

### C Standard definitions

<cstddef> (stddef.h)
This header defines several types implicitly generated or used by certain language expressions.

Types

ptrdiff_t
    Result of pointer subtraction (type )

size_t
    Unsigned integral type (type )

max_align_t
    Type with widest scalar alignment (type )

nullptr_t
    Null pointer type (C++) (type )


In C, this header also includes the declaration of the wchar_t type (wide character type), which in C++ is a language keyword that identifies a distinct fundamental type (no header inclusion required in C++).

Macro functions

offsetof
    Return member offset (macro )


Macro constants

NULL
    Null pointer (macro )



### Variable arguments handling

<cstdarg> (stdarg.h)

This header defines macros to access the individual arguments of a list of unnamed arguments whose number and types are not known to the called function.

A function may accept a varying number of additional arguments without corresponding parameter declarations by including a comma and three dots (,...) after its regular named parameters:

return_type function_name ( parameter_declarations , ... );
To access these additional arguments the macros va_start, va_arg and va_end, declared in this header, can be used:

    First, va_start initializes the list of variable arguments as a va_list.
    Subsequent executions of va_arg yield the values of the additional arguments in the same order as passed to the function.
    Finally, va_end shall be executed before the function returns.


Types

- `va_list`- Type to hold information about variable arguments (type )


Macro functions

- `va_start`- Initialize a variable argument list (macro )
- `va_arg`- Retrieve next argument (macro )
- `va_end`- End using variable argument list (macro )
- `va_copy`- Copy variable argument list (macro )


short - 2bytes -32,000-32000
unsigned short - 64000
int - could be 2 or 4 bytes (short or long)
long 4 bytes 2^32
float
double
long doubles
chars `' '` (Single quotes)
string `" "` (Double quotes)
bool 

[<cstdint> (stdint.h) - C++ Reference](https://www.cplusplus.com/reference/cstdint/)

/todo edit
```
signed type	unsigned type	description
intmax_t	uintmax_t	Integer type with the maximum width supported.
int8_t	uint8_t	Integer type with a width of exactly 8, 16, 32, or 64 bits.
For signed types, negative values are represented using 2's complement.
No padding bits.
Optional: These typedefs are not defined if no types with such characteristics exist.*
int16_t	uint16_t
int32_t	uint32_t
int64_t	uint64_t
int_least8_t	uint_least8_t	Integer type with a minimum of 8, 16, 32, or 64 bits.
No other integer type exists with lesser size and at least the specified width.
int_least16_t	uint_least16_t
int_least32_t	uint_least32_t
int_least64_t	uint_least64_t
int_fast8_t	uint_fast8_t	Integer type with a minimum of 8, 16, 32, or 64 bits.
At least as fast as any other integer type with at least the specified width.
int_fast16_t	uint_fast16_t
int_fast32_t	uint_fast32_t
int_fast64_t	uint_fast64_t
intptr_t	uintptr_t	Integer type capable of holding a value converted from a void pointer and then be converted back to that type with a value that compares equal to the original pointer.
Optional: These typedefs may not be defined in some library implementations.*


header
<cstdint> (stdint.h)
Integer types
This header defines a set of integral type aliases with specific width requirements, along with macros specifying their limits and macro functions to create values of these types.

Types
The following are typedefs of fundamental integral types or extended integral types.

signed type	unsigned type	description
intmax_t	uintmax_t	Integer type with the maximum width supported.
int8_t	uint8_t	Integer type with a width of exactly 8, 16, 32, or 64 bits.
For signed types, negative values are represented using 2's complement.
No padding bits.
Optional: These typedefs are not defined if no types with such characteristics exist.*
int16_t	uint16_t
int32_t	uint32_t
int64_t	uint64_t
int_least8_t	uint_least8_t	Integer type with a minimum of 8, 16, 32, or 64 bits.
No other integer type exists with lesser size and at least the specified width.
int_least16_t	uint_least16_t
int_least32_t	uint_least32_t
int_least64_t	uint_least64_t
int_fast8_t	uint_fast8_t	Integer type with a minimum of 8, 16, 32, or 64 bits.
At least as fast as any other integer type with at least the specified width.
int_fast16_t	uint_fast16_t
int_fast32_t	uint_fast32_t
int_fast64_t	uint_fast64_t
intptr_t	uintptr_t	Integer type capable of holding a value converted from a void pointer and then be converted back to that type with a value that compares equal to the original pointer.
Optional: These typedefs may not be defined in some library implementations.*

Some of these typedefs may denote the same types. Therefore, function overloads should not rely on these being different.

* Notice that some types are optional (and thus, with no portability guarantees). A particular library implementation may also define additional types with other widths supported by its system. In any case, if either the signed or the unsigned version is defined, both the signed and unsigned versions are defined.

Macros

Limits of cstdint types
Macro	description	defined as
INTMAX_MIN	Minimum value of intmax_t	-(263-1), or lower
INTMAX_MAX	Maximum value of intmax_t	263-1, or higher
UINTMAX_MAX	Maximum value of uintmax_t	264-1, or higher
INTN_MIN	Minimum value of exact-width signed type	Exactly -2(N-1)
INTN_MAX	Maximum value of exact-width signed type	Exactly 2(N-1)-1
UINTN_MAX	Maximum value of exact-width unsigned type	Exactly 2N-1
INT_LEASTN_MIN	Minimum value of minimum-width signed type	-(2(N-1)-1), or lower
INT_LEASTN_MAX	Maximum value of minimum-width signed type	2(N-1)-1, or higher
UINT_LEASTN_MAX	Maximum value of minimum-width unsigned type	2N-1, or higher
INT_FASTN_MIN	Minimum value of fastest minimum-width signed type	-(2(N-1)-1), or lower
INT_FASTN_MAX	Maximum value of fastest minimum-width signed type	2(N-1)-1, or higher
UINT_FASTN_MAX	Maximum value of fastest minimum-width unsigned type	2N-1, or higher
INTPTR_MIN	Minimum value of intptr_t	-(215-1), or lower
INTPTR_MAX	Maximum value of intptr_t	215-1, or higher
UINTPTR_MAX	Maximum value of uintptr_t	216-1, or higher
Where N is one in 8, 16, 32, 64, or any other type width supported by the library.

Only the macros corresponding to types supported by the library are defined.

Limits of other types
Limits of other standard integral types:
Macro	description	defined as
SIZE_MAX	Maximum value of size_t	264-1, or higher
PTRDIFF_MIN	Minimum value of ptrdiff_t	-(216-1), or lower
PTRDIFF_MAX	Maximum value of ptrdiff_t	216-1, or higher
SIG_ATOMIC_MIN	Minimum value of sig_atomic_t	if sig_atomic_t is signed: -127, or lower
if sig_atomic_t is unsigned: 0
SIG_ATOMIC_MAX	Maximum value of sig_atomic_t	if sig_atomic_t is signed: 127, or higher
if sig_atomic_t is unsigned: 255, or higher
WCHAR_MIN	Minimum value of wchar_t	if wchar_t is signed: -127, or lower
if wchar_t is unsigned: 0
WCHAR_MAX	Maximum value of wchar_t	if wchar_t is signed: 127, or higher
if wchar_t is unsigned: 255, or higher
WINT_MIN	Minimum value of wint_t	if wint_t is signed: -32767, or lower
if wint_t is unsigned: 0
WINT_MAX	Maximum value of wint_t	if wint_t is signed: 32767, or higher
if wint_t is unsigned: 65535, or higher

Function-like macros
These function-like macros expand to integer constants suitable to initialize objects of the types above:
Macro	description
INTMAX_C	expands to a value of type intmax_t
UINTMAX_C	expands to a value of type uintmax_t
INTN_C	expands to a value of type int_leastN_t
UINTN_C	expands to a value of type uint_leastN_t

For example:

 

	

INTMAX_C(2012)  // expands to 2012LL or similar 
```

**character** - `char` - Used to hold a single character of information.  Always requires a single byte of storage.

**integer** - `int` - Used to hold a signed whole number quantity.

**short integer** - `short` - Used to hold a signed whole number quantity.  Typically only requires half the storage requirements of a signed integer.

**long integer** - `long` - Used to hold a signed whole number quantity.  Typically requires twice as much storage as a normal signed integer.

**unsigned integer** - `unsigned` - Used to hold non-negative whole number quantities.

**floating point** - `float` - Used to hold signed numbers with fractional components.


**double precision** - `double` - Used to hold signed numbers with fractional components.  Typically requires twice the storage as a float.


**extended precision** - `long double` - Extended precision for floating point types.  Implemented as part of ISO/ANSI standard.

**boolean** - `bool` - Used to hold literal values true and false.

**constant** - `const` - Used to hold a constant value that cannot be changed during program execution.



**long long integer** - `long long` - Range is at least the same as long, but varies with compiler.

**unsigned long long integer** - `unsigned long long` - Extended range unsigned integer.

**16-bit character** - `char16_t` - A single 16-bit character.


**32-bit character** - `char32_t` - A single 32-bit character.


**automatic** - `auto` - The compiler will decide the type automatically.


**decltype** - `decltype( expr )` - The compiler determines the type of the expression expr. Useful for use with templates.


bool types can be used to create state variables that indicate truth or falsity
bool variables can be assigned the literal values true and false
The default value of a bool type is false


### Strings


`std::string_view` - C++17 - you can replace `std::string_view` with `const std::string&`. String_view is just a wrapper for a pointer and a length.

**Class templates**

- `basic_string` - Generic string class (class template )

- `char_traits` - Character traits (class template )


Class instantiations

- `string` - String class (class )

- `u16string` - String of 16-bit characters (class )

- `u32string` - String of 32-bit characters (class )

- `wstring` - Wide string (class )


Functions
Convert from strings

- `stoi` - Convert string to integer (function template )

- `stol` - Convert string to long int (function template )

- `stoul` - Convert string to unsigned integer (function template )

- `stoll` - Convert string to long long (function template )

- `stoull` - Convert string to unsigned long long (function template )

- `stof` - Convert string to float (function template )

- `stod` - Convert string to double (function template )

- `stold` - Convert string to long double (function template )


Convert to strings

- `to_string` - Convert numerical value to string (function )

- `to_wstring` - Convert numerical value to wide string (function )


Range access

- `begin` - Iterator to beginning (function template )

- `end` - Iterator to end (function template )




### Type Inference & Alternative Function Syntax 

C++ 11

Compiler deduces type at compile time

`auto` keyword.

```c++
auto x = 99;         

auto value = myFunc();


// Alternative Function Syntax … most useful when using
// templates


//function myfunc takes an int and returns an int, using below.  

//is this a lambda
auto myFunc( int x ) -> int
{
    return 2*x;
}


// Ask the compiler to figure out return type … most useful
// when using templates

auto myFunc( float v1, float v2 )
{
    return v1 * v2;
}

```

___
## Symbols, Operators, and Keywords
___




### Reserved Keywords

//42



###

## Pointers
___

Some good links:
 
- [FAQ Lite](https://isocpp.org/wiki/faq/references#refs-vs-ptrs)

- [When do we pass by ref or pointer](https://www.geeksforgeeks.org/when-do-we-pass-arguments-by-reference-or-pointer/)

- [Pointers vs Ref (src for most of below)](https://www.geeksforgeeks.org/pointers-vs-references-cpp/)

- [See more](https://www.geeksforgeeks.org/pointers-and-references-in-c/?ref=rp)

- [And more- good](https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/)

![Image](https://www.geeksforgeeks.org/wp-content/uploads/How-Pointer-Works-In-C.png)




```c++
int i = 3; 
int *ptr = &i; // A pointer to variable i (or stores addr of i)
int &ref = i; // A reference (or alias) for i.

int *p = &a;    
//OR
int *p;  p = &a;

int &p=a;  //it is correct
   but
int &p; p=a;   // it is incorrect as we should declare and initialize references at single step.
```

4. Reassignment: A pointer can be re-assigned. This property is useful for implementation of data structures like linked list, tree, etc. See the following examples: 


```c++
int a = 5;
int b = 6;
int *p;
p =  &a;
p = &b;
```

But the converse is not true:


```c++
int a = 5;
int b = 6;
int &p = a;
int &p = b;  //At this line it will show error as "multiple declaration is not allowed".
//However it is valid statement,
int &q=p;
```

6. Memory Address: A **pointer has its own memory address and size on the stack** whereas a **reference shares the same memory address** (with the original variable) but also takes up some space on the stack.

```c++
   int &p = a;
   cout << &p << endl << &a;
```
7. NULL value: Pointer can be assigned NULL directly, whereas reference cannot. The constraints associated with references (no NULL, no reassignment) ensure that the underlying operations do not run into exception situation.

8. Indirection: You can have pointers to pointers offering extra levels of indirection. Whereas references only offer one level of indirection.I.e, 

In Pointers, you can have pointers to pointers etc, but references cannot because they are teh same as the object.

```c++
int a = 10;
int *p;
int **q;  //it is valid.
p = &a;
q = &p;
a & p(*) & q(**) * p(*) * a

Whereas in references,

int &p = a;
int &&q = p; //it is reference to reference, so it is an error.
```



### Passing Objects

The best way is to provide the myGLCD object as a parameter to the constructor:

```c++
touchButton::touchButton(UTFT &glcddev, int x, int y, int xs, int ys, char myuse) {
  x1 = x;
  y1 = y;
  xsize = xs;
  ysize = ys;
  use = myuse;
  glcd = &glcddev;
}
```

Then in your header you provide a:
```c++
private: 
  UTFT *glcd;
Your library code then uses the glcd pointer to the object:

**glcd->drawRoundedRectangle(...);**
``` 

Note the use of `->` since glcd is a pointer to the object (as created by the & operator when it was assigned in the constructor).



## Enums

```c++
enum PieceType(PieceTypeKing, PieceTypeQueen, PieceTypeRook);
```

Creates an enum, just carries the numerical int value of position. 
You can also specify values-


```c++
enum PieceType(PieceTypeKing = 2, PieceTypeQueen, PieceTypeRook=10, PieceTypeKnight);
```

The values following will just be incremented.  e.g. King = 2, Q=3 R=10, K=11.

### Strongly Typed Enums

The above always has the value given underneath.  This allows you (perhaps inappropriately) to compare two unrelated *enums*.

To prevent that- use strongly typed ones.

this is the type safe version.


```c++
enum class PieceType
{
   King=1,
   Queen,
   Rook,
   Pawn
};
```

For an enum class, the enumeration value names are not automatically exported to the enclosing scope, which means that you always have to use the scope resolution operator:


`PieceType piece = PieceType::King;`

These do not have underlying integer values, assigning numbers like above is an error.

`if(PieceType::Queen==1){} //error`


```c++
enum class PieceType : unsigned long
{
   King = 1,
   Queen,
   Rook = 10,
   Pawn
};
```

### Iterable Enums



[How to iterate over enums](https://stackoverflow.com/questions/261963/how-can-i-iterate-over-an-enum)


Iterable Enums

```c++
num Foo {
  One,
  Two,
  Three,
  Last
};

for ( int fooInt = One; fooInt != Last; fooInt++ )
{
   Foo foo = static_cast<Foo>(fooInt);
   // ...
}
``` 

```c++
#include <iostream>
#include <algorithm>

namespace MyEnum
{
  enum Type
  {
    a = 100,
    b = 220,
    c = -1
  };

  static const Type All[] = { a, b, c };
}

void fun( const MyEnum::Type e )
{
  std::cout << e << std::endl;
}

int main()
{
  // all
  for ( const auto e : MyEnum::All )
    fun( e );

  // some
  for ( const auto e : { MyEnum::a, MyEnum::b } )
    fun( e );

  // all
  std::for_each( std::begin( MyEnum::All ), std::end( MyEnum::All ), fun );

  return 0;
}
```


## Structs

Binds types into a new type.  Structs are the same as classes, but all items are public.

```c++
struct Car{

   int year;
   int miles;
   std::string make;
   int getValue() const;
}

struct SpreadsheetCell
{
      void setValue(double inValue);
      double getValue() const;
   private: //can have methods and private members
      double mValue;
};
```

You declare a car by just defining it: `Car car;`

Then access each value with the `.` operator.

### typedef

Using `typedef` on a `struct` defines it for external linkage.


`typedef struct { /* ... */ } S;`

---
---
## Control
---
- Iteration constructs
   - for
   - while
   - do-while
   - 'enhanced' for (C++ 11)
- Decision constructs
   - if-else
   - switch
   - conditional
- Other constructs
   - goto
   - break - used with switch.
   - continue - can be high risk

!!! question continue - said hed make a comment if used.

## Variables

- Variable names must begin with a letter or an underscore…remaining characters in a may be letters, digits or underscores
   - Avoid beginning names with single or double underscores
- Upper & lowercase letters are distinct
- All characters in a variable name are significant
- Must be declared, can be anywhere.

```c++
#include    <iostream>
using namespace std;
int main()
{
    int a;        // value of a is undefined
    int b = 10;
    cout << b << endl;
    int z = 99;    // can't do this in C language, but OK in C++
    cout << z << endl;

    for( int j = 0; j < 3; j++ )        // scope of j is for loop
    {
        cout << "j is " << j << endl;
    }

    return 0;
}
```

### Initialization


int valueX; // this could be anything, whatever happens to be in the reused memory function
Copy Initialization: `int valueX = 0; `
Direct Initialization: `int valueX(0);`
Uniform Initialization (aka Brace Initialization): `int valueX{0};`
   - Zero Initialization: `int valueX{}` - initializes to zero or empty depending on value.

int valueX[0] returns a pointer, because this is actually a c-style array.

Using bracket assignment- it will warn about truncation.

eg `int x = 3.14` - x = 3

```c++
int hamburgers = {16};    // set hamburgers to 16
int hotdogs {3};        // set hotdogs to 3
int mustard {};        // set mustard to 0
int relish = {};        // set relish to 0
int ketchup(1);        // set ketchup to 1

long double x = 3.14159;
int a{x}, b = {x};        // truncation error
int c(x), d = x;        // ok – but will truncate.  Using these assingment methods wont have checking.
int a =3;
int b{3};
int c = {3};
int d(3);
```

Uniform initialization (using `{}`) calls the default initializer for each item.  Especially for `0` initialization.  Primitive int and non float chars are 0, all floating pt values 0.0, and pointer values are `nullptr`

It prevents narrowing.

```c++
void func(int i){/* */}

int x = 3.14 //auto narrows to 3.
func(3.14); //passes 3 automatically
//these may result in a compiler error for narrowing.

int x{3.14} //error
int x = {3.14} //error
func{(3.14)} //error

```

### List Initialization

There is a difference with Copy `=` and Direct Initilization in C++17

#### Direct List Initialization

`T obj {arg1, arg2, ...}`

```c++
auto a {11}; //int

auto b {11, 22}; //Error - no list one element allowed
```

#### Copy List Initialization

`T obj = {arg1, arg2, ...}`

```c++
auto a = {11}; //initilizer list<int>

auto b = {11, 22}; //initilizer list<int>
auto c = {11, 22.2} //ERROR must be same type
```

### Scoping

`static` keyword- allocates memory in .data segment at compile time, is loaded at execution and remains in memory for the duration.

//to do week 2

`inline` 

`extern` - used to declare an object without defining it.  States that it is defined elsewhere in the Linkage units- e.g. in another file.

      `extern int n;` - ok 
      `extern int n = 0;` not ok.

      To define you need:

      `extern const int n = 0`
#### namespaces

### Casting

`sstatic_cast<T>(v);`

Assigning a value to increasing precision is ok

eg. a float -> double

to force a cast to lower precision (e.g. double assigned to int)





```c++
int intVal;
double dbVal1, dbVal2;
intVal = dbVal1 + dbVal2; //Causes error
intval = static_cast<int>(dbVal1 + dbVal2);
```

### Type Promotion

int integer
float flt

flt + integer = float 
flt - integer = float 
flt * integer = float 
flt / integer = float 
int / float = int
float % int = error
int % float = error **

Only int % int is allowed.


## Constants

- Literal constants are values that appear in a program (e.g. 33, 12.99, 'A', "Hello")
- Literal constants are not addressable - Can't directly address memory where value is stored
- Every literal constant has an associated type

Literal integer constants are treated as signed values of type int


      34        // decimal notation
      036        // octal
      0x14        // hexadecimal
      128L        // long (could also use l )
      128U        // unsigned (could also use u )
      14UL        // long unsigned
      14LL        // long long*
      128ULL        // unsigned long long*
      3.14159F    // float (could also use f )
      0.0        // double (default type)
      7.435L        // extended precision
      4e2        // scientific notation 
      2.35E-2    // scientific notation

f = F = float.

Printable literal character constants written with character inside single quotes


      'G'        // letter G
      ','        // literal comma
      ' '        // literal blank
      '5'        // literal 5

Nonprintable characters, the single & double quote marks, and the backslash are represented using escape sequences

      \n        // newline
      \b    // backspace
      \t        // horizontal tab        
      \v    // vertical tab
      \r        // carriage return    
      \f    // formfeed
      \a        // alert (bell)        
      \\    // backslash
      \'        // single quote        
      \"    // double quote

Can also use \xxx where xxx is a sequence of up to 3 octal digits

        \0    // null            
      \7    // bell
        \14    // newline        
      \062    // '2'


Can be used to transform a variable into an addressable constant
Must be initialized in its declaration


const float pi = 3.14159;    // pi is a constant
const int c;        // ERROR!! must be initialized in declaration
pi = 22.3;        // ERROR!! can't change value


### String Literals

String literals consist of zero or more characters enclosed in double quotes. Compiler adds terminating null character
Treated as an array of constant (const) characters
Nonprintable characters are represented by their escape sequences
        ""            // null string
        "A"            // not same as char literal 'A'
        "Hello"        // String literal
        "Hello \t World"    // Embedded escape sequence
        "Multiple line \    // Can extend for several lines
        literal"        // using a backslash as the 
                    // last character on a line

### Boolean literals

      true, false


## Complex Types


arrays, structures (type struct), unions (type union), and enumerators (type enum) are legacy types from C
C++ structures can have functions as well as data types as members
The class type will be discussed later in this course


### Arrays

[Array Deep Dive (good)](https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c/4810668#4810668)



Zero indexed.

C++ you must give a size to the array.  This size cannot be a variable, it must be a constant, or a constant expression (*constexpr*)


```c++
int myArray[3];
myArray[0]=0;
myArray[1]=0;
myArray[2]=0;
```
This is declaring by initializer list:

`int[] array = {1,2,3,4}` you can set each val to zero like:

`int array[3] = {0};` further this is equivalent to 

`int array[3]={}` eg. you dont need to state zero. Also, note that, 

`int arr[3] = {2}` does not set each to 2, but sets the first to 2 and the rest to zero.  Also, this 

`int arr[]={2}` creates an array of length = 1 and value arr[0] = 2. (e.g size will be deduced from given values.


#### Assignment

For no particular reason, arrays cannot be assigned to one another. Use std::copy instead:


```c++
#include <algorithm>

// ...

int a[8] = {2, 3, 5, 7, 11, 13, 17, 19};
int b[8];
std::copy(a + 0, a + 8, b);
//(<start>, <end- exclusive>, <dest>)
```

**passing arrays**

```c++
void myFunction(int *param) { ..}

void myFunction(int param[10]) {

void myFunction(int param[], d) {

```
`int arg[]` is adjusted to be `int* arg` (**Decomposed:** see below) when passed to a function.


!!! Caution  Caution: Be careful of the above types: That is a pointer to ints, not an int.
      `int array[3] = {0};`

A template solution- which at this time I dont undersand

[Here](https://stackoverflow.com/questions/968001/determine-size-of-array-if-passed-to-function)




```c++
    template <typename T, int N>
    void func(T (&a) [N]) {
        for (int i = 0; i < N; ++i) a[i] = T(); // reset all elements
    }
int x[10];
func(x);
```


**Array-to-pointer decay** The only "connection" between T[n] and T[m] is that both types can implicitly be converted to T*, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a T* is required, you can provide a T[n], and the compiler will silently provide that pointer: This conversion is known as "array-to-pointer decay", and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (T*).

The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer


**size** -  get the size with

      unsigned int arraySize = std::size(myArray)

This only works in C++ 17++ (and not for me... in 20+...) so you can use the trick:

       unsigned int arraySize = = sizeof(myArray) / sizeof(myArray[0])
   
This is a hack that finds the whole size, divided by 1 element, which should equal # elements.



```c++
#include <type_traits>

static_assert(!std::is_same<int[8], float[8]>::value, "distinct element type");
static_assert(!std::is_same<int[8],   int[9]>::value, "distinct size");

static_assert(!std::is_same<int[8], int*>::value, "an array is not a pointer");
```
Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. sizeof(T[n]) is equivalent to n * sizeof(T).

`static_assert(!std::is_same<int*, int(*)[8]>::value, "distinct element type");`


One important context in which an array does not decay into a pointer to its first element is when the `&` operator is applied to it. The `&` operator yields a pointer to the entire array, not just a pointer to its first element. Although in that case the values (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:

The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same value (the same address), yet they are completely distinct types.

If you are unfamiliar with the C declarator syntax, the parenthesis in the type int(*)[8] are essential:

    `int(*)[8]` is a pointer to an array of 8 integers.
    `int*[8]` is an array of 8 pointers, each element of type int*.

note i tried putting these in C++ and they werenet liked.

Actually the syntax looks like this: (the 2nd item)


```c++
int array_of_arrays[6][7];
int (*pointer_to_array)[7] = array_of_arrays;

int* array_of_pointers[6];
int** pointer_to_pointer = array_of_pointers;
```



In adding to an array:


Since the syntax `*(x+i)` is a bit clumsy, C++ provides the alternative syntax `x[i]`:

```c++
int x[8]={};
x+3 ; //has no meaning but it decomposes into a pointer, and adds 3 to the pointer. giving the 3rd element.

std::cout << 3[x] << ", " << 7[x] << std::endl; //Due to the fact that addition is commutative, these are the same.
```

For length of n- an array will let you compute pointers to 0...nth items.  However, the nth item is nonexistant and would throw and error dereferenced.


```c++
std::sort(x + 0, x + n);
std::sort(&x[0], &x[0] + n);
std::sort(&x[0], &x[n]); //error- this is equivalent to &*(x+n), and the sub-expression *(x+n) 
```
An Array name is a special pointer, its a fixed pointer.  You can add to the array.

`pos = array + 1;`

However you cannot reassign the array or start of the array.

`array +=1; //error`
### Arrays of pointers

You can overcome the restriction of fixed width by introducing another level of indirection.
Named arrays of pointers

Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:


```c++
int* triangle[5];
for (int i = 0; i < 5; ++i)
{
    triangle[i] = new int[5 - i];
}

// ...

for (int i = 0; i < 5; ++i)
{
    delete[] triangle[i];
}
```
```c++
int array[8] = {};
int(*) ptr_to_array[8] = &array
```

### Multidimensional arrays


Programmers often confuse multidimensional arrays with arrays of pointers.

Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as **"arrays of arrays"** or **"true multidimensional arrays".**


When using named multidimensional arrays, all dimensions must be known at compile time:


```c++

int H = read_int();
int W = read_int();

int connect_four[6][7];   // okay

int connect_four[H][7];   // ISO C++ forbids variable length array
int connect_four[6][W];   // ISO C++ forbids variable length array
int connect_four[H][W];   // ISO C++ forbids variable length array
```







### structure

You define struct names at the end:

```c++
   #include <string>

    typedef struct {
        string valueName;
        long long value;
    } values;
```


### class

### union

### enumerator

   [See Enumbs section](#Enums)



47-84, 114-134

### Vectors

[See Initializer Lists for examples](#Initializer Lists)


```c++
vector<double> mSequence;
std::vector<std::string> myVec = {"String 1", "String 2", "String 3"};
std::vector<std::string> myVec;
myVec.push_back("String 1");
myVec.push_back("String 2");
myVec.push_back("String 3");
mSequence.assign(args);
```



## Strings


### String Stream

[StringStream](https://stackoverflow.com/questions/2462951/c-equivalent-of-stringbuffer-stringbuilder)



```c++
#include <string>
#include <iosteam.h>
cout << "HELLO WORLD"
cin>>readVal

#include <sstream>
std::stringstream ss;
ss << "my data " << 42;
std::string myString( ss.str() );
//or  return ss.str();
```

uses `cout` `cin`  and `<<` `>>`

printf and fprintf and scanf are available in **_<cstdio>_** / <stdio.h>



endl

//38
//39


### string manipulator

 std::setprecision(2);

- std::fixed
- std::strcat(str, str2);

- Defined in header *\<ios\>*
   - `boolalpha`
   - `noboolalpha`
      - switches between textual and numeric representation of booleans
   - `showbase`
   - `noshowbase`
      - controls whether prefix is used to indicate numeric base
   - `showpoint`
   - `noshowpoint`
      - controls whether decimal point is always included in floating-point representation
   - `showpos`
   - `noshowpos`
      - controls whether the + sign used with non-negative numbers
   - `skipws`
   - `noskipws`
      - controls whether leading whitespace is skipped on input
   - `uppercase`
   - `nouppercase`
      - controls whether uppercase characters are used with some output formats
   - `unitbuf`
   - `nounitbuf`
   - controls whether output is flushed after each operation
   - `internal`
   - `left`
   - `right`
      - sets the placement of fill characters
   - `dec`
   - `hex`
   - `oct`
      - changes the base used for integer I/O
   - `fixed`
   - `scientific`
   - `hexfloat` **(C++11)**
   - `defaultfloat` **(C++11)**
      - changes formatting used for floating-point I/O
- Defined in header *\<istream\>*
   - `ws` - consumes whitespace
- Defined in header *\<ostream\>*
   - `ends`  outputs '\0'
   - `flush` flushes the output stream
   - `endl` - outputs '\n' and flushes the output stream
   - `emit_on_flush` **(C++20)**
   - `no_emit_on_flush` **(C++20)**
      - controls whether a stream's basic_syncbuf emits on flush
   - `flush_emit` **(C++20)** - flushes a stream and emits the content if it is using a basic_syncbuf
- Defined in header *\<iomanip\>*
   - `resetiosflags` - clears the specified ios_base flags
   - `setiosflags`   - sets the specified ios_base flags
   - `setbase`- changes the base used for integer I/O
   - `setfill`- changes the fill character
   - `setprecision`- changes floating-point precision
   - `setw`- changes the width of the next input/output field
   - `get_money`- **(C++11)**- parses a monetary value
   - `put_money`- **(C++11)**- formats and outputs a monetary value
   - `get_time`- **(C++11)**- parses a date/time value of specified format
   - `put_time`- **(C++11)**- formats and outputs a date/time value according to the specified format
   - `quoted` - **(C++14)** - inserts and extracts quoted strings with embedded spaces
```c++
//40
// Program to read and display a line of input
//
// Program Input:    That's better
//
// Program Output:    You entered: That's better

#include    <iostream>
using namespace std;
int main()
{
    char line[81];
    char c;
    int i = 0;

    cin >> noskipws;        // use manipulator to recognize whitespace

    cout << "Please enter a line of text: ";

    while ( ( cin >> c ) && ( c != '\n' ) )
        line[i++] = c;

    line[i] = '\0';

    cout << "\n\nYou entered: " << line << endl;
    return 0;
}
```

## Mixing Input Types

//41

## Functions

- Two basic types of functions
   - Ordinary functions --- like in C
   - Class member functions --- used in O-O programs
- A function definition (i.e., its code) or a function prototype must appear in the code before the function is invoked
- Normal practice is to use function prototypes
- Functions may have arguments & may return a value

//46

Functions need to appear before they are used, so a protoype has to occur.

```c++
#include    <iostream>
using namespace std;


//function prototypes
void print_message();        // A function prototype
float product( int , float ); // Another prototype

            void main()
            {
                float k = 13.54f;
                float num = 43.77f;

                print_message();        // Invoking functions
                cout << product( k , num );
            }

            // Function definitions

void print_message()
            {
                cout << "Where's the Beef?" << " \n";
            }

            float product ( int c , float f )
            {
                return ( c * f );
            }
```

Typically placed at top of source file or "included" via a pre-processor directive

When placed outside of a function scope is from point of placement to end of source file

When placed inside a function scope is from point of placement to end of function

```c++

#include    <iostream>
using namespace std;

void myfunc();        // Scope is source file
void message();

void main()
{
    message();
    myfunc();
}

void myfunc()
{
    int afunc();    // Scope is myfunc()

    message();
    cout << afunc();
}

int afunc() { return 99; }

void message() { cout << "HELLO \n"; }

```

### Passing Arguments and Returning

//49

//50

### Using const With Function Arguments

If a value passed as a function argument should not be altered in the function, the argument should be declared as `const`

The C++ compiler will not allow const arguments to be modified by a function


```c++
// Function taking const argument

void myfunc( int arg1, const int arg2 )
{
    arg1 = 2*arg1;        // OK
    arg2 += arg1;        // ERROR --- can't change arg2
}
```

___
## Classes 
---


```c++
class SpreadsheetCell
{
// Remainder of the class definition omitted for brevity
private:
double mValue = 0;
};


<in class.cpp>
#include "SpreadsheetCell.h"

void SpreadsheetCell::setValue(double inValue)
{
   mValue = inValue;
}

double SpreadsheetCell::getValue() const  //use const when values arent changing
{
   return mValue;
}
```

```c++
// in header file
class touchButton {
  public:
    touchButton(int x, int y, int xs, int ys, char use);
    void Draw();
    int x1;
    int y1;
    int xsize;
    int ysize;
    char use;
    boolean toggle = false;
};

```


```c++
//in body
  touchButton::touchButton(int x, int y, int xs, int ys, char myuse) {
    x1 = x;
    y1 = y;
    xsize = xs;
    ysize = ys;
    use = myuse;
  }

  void touchButton::Draw() {
    switch (use) {
      case 'p':
      //this is what I would like to have called from the main file.
      //myGLCD.drawRoundRect(x1, y1, x1+xsize, y1+ysize);
        break;

       default:
        break;
    }
  }

  ```


### Brief assignment
---

   `CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}`
   
### Instantiation Overview 

[See Below](#Stack instantiation)

```c++
SpreadsheetCell myCell
SpreadsheetCell myCell(); // WRONG, but will compile.
myCell.setValue(6); //wont fail until <-here
//it must be like this:
SpreadsheetCell myCell;

SpreadsheetCell myCell(5), anotherCell (4);
```

The following are heap initialized.  They are not controlled by scope - eg not deleted when exit method.

```c++
//C++11 style
unique_ptr<SpreadsheetCell> myCellP{make_unique<SpreadsheetCell>()}
//C++14 style
auto myCellp = make_unique<SpreadsheetCell>();
// Equivalent to:
unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
//<C++11 requires raw pointers.
// Or with raw pointers, without smart pointers (not recommended)
SpreadsheeCell* myCellp = new SpreadsheetCell();
SpreadsheetCell* myCellp = new SpreadsheetCell(5);
SpreadsheetCell* anotherCellp = nullptr;  //if not used immed. make `nullptr`
anotherCellp = new SpreadsheetCell(4);

delete myCellp;
myCellp = nullptr;
```

generally: 

for C++ 14+
`auto [varName] = make_unique<[Class]> ( [ctor params] );`

for C++11+
`unique_ptr< [Class] > [varName] (new [Class]( [ctor params] ));`

for < C++ 11
`[Class]* [varName] = new [Class]( [ctor params] )`

### Uniform Initialization
---

Structs and classes can be initiated similarly

```c++

stuct CircleStruct{
   int x,y ;
   double radius;
}
class CircleClass{
   public:
   CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}

}
CircleStruct myCircle = {10, 10, 2.5}
CircleStruct myCircle4{10, 10, 2.5}
CircleClass myCircle2{10, 10, 2.5};
CircleClass myCircle3 = {10, 10, 2.5};
```


---
### Constructors
---

!!!NOTE C++ programmers sometimes call a constructor a ctor.

You cannot declare a constructor in terms of another:


```c++
SpreadsheetCell::SpreadsheetCell(string_view initialValue)
{
      SpreadsheetCell(stringToDouble(initialValue));
}
```

The code will compile, link, and run, but will not do what you expect. It creates a temp object then dumps it on return. You can use **Delegate constructors**
?Can you return it?

Default constructors are needed - a constructor with 0 params- especially **if the object may be used in an array**.  A default constructor is also required for classes that you want to store in Standard Library containers, such as `std::vector`.


```c++
SpreadsheetCell cells[3]; // FAILS compilation without default constructor
SpreadsheetCell* myCellp = new SpreadsheetCell[10]; // Also FAILS
```

You can circumvent this restriction for stack-based arrays by using initializers like these:

```c++
SpreadsheetCell cells[3] = {SpreadsheetCell(0), SpreadsheetCell(23),
**SpreadsheetCell(41)};**
```

There is an *implicit* default constructor, unless an explicit constructor is defined.  Then you need to explicitly declare the default if you want it available.  If you explicitly don't want a default constructor, and have no others, you need to explicitly delete it.


```c++
class MyClass
{
public:
   MyClass() = default;
   MyClass(double initialValue);
   MyClass(std::string_view initialValue);

   //explicit deletion of default.  No constructor.
public:
   MyClass() = delete;
};
```

---
#### Constructor Initializers
---

```c++
SpreadsheetCell::SpreadsheetCell(double initialValue): mValue(initialValue){}
```

Each element in the list is an initialization of a data member using function notation or the uniform initialization syntax, a call to a base class constructor (see Chapter 10), or a call to a delegated constructor, which is discussed later.

The initializer list is of format `:` then a comma separated list.



```c++
class SpreadsheetCell
{
   public:
      SpreadsheetCell(double d);
};

class SomeClass
{
   public:
      SomeClass();
   private:
      SpreadsheetCell mCell; //no value assigned, and no default
}; 

SomeClass::SomeClass() { } //err

SomeClass::SomeClass() : mCell(1.0) { } //now works/
```

!!!Warning ctor-initializers initialize data members in the order that they appear in the class definition, not their order in the ctor-initializer.


#### Copy Constructors

Will be created by default, unless you explicitly delete or declare a new one.  But the general form is here:

1. When a class object is created and initialized with an existing object of the class.
2. When a class object is passed by value as a function arg.
3. When a class is returned from a function.

This is (the default version) us a shallow copy

This is ok if the class only has primitive types as members or if the class does not have any pointers or reference types.

-if there is a pointer in the object, then copying object 1 to object 2, affecting object 1 will affect object 2 (if there is a pointer `int* a` for instance both objects point to the same `int * a`)                                                         



```c++
SpreadsheetCell(const SpreadsheetCell& src);
SpreadsheetCell(const SpreadsheetCell src); //doing this causes infinitate recursion- because it calls copy constructor here- to copy input to src...
// used like this in implementation
SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
: mValue(src.mValue)
{
}
```

!!!Info Info: This is important because C++ is pass by Value, so by default Objects are copied before passing to functions or methods.

If **either** the `Copy` or `Copy Assignment` constructor or destructor is declared, the other *will not* be (given a default).

To add it back:


```c++
MyClass(const MyClass& src) = default;

MyClass& operator=(const MyClass& rhs) = default;
```




Utilizing the copy constructor:

```c++
MyClass myClass(params);
MyClass copyClass(myClass);
```

where possible, pass by `const reference`.  Returning by Reference can be risky.  E.g. if you create a string in a method, and then return it by reference to avoid copying, the address  will be returned, but the underlying string will be dumped.

Explicitly declare or remove the copy constructor (e.g. you dont want an object copied.) This can be used to disallow passing the object by value,

```c++
SpreadsheetCell(const SpreadsheetCell& src) = default;
SpreadsheetCell(const SpreadsheetCell& src) = delete;1
```
___

#### Copy assignment 

Works by setting one, existing object to entirely match the other.

```c++
Object o(params);
Object oo(params);
oo=o;
```

At the end both still exist, just oo matches o.  

This constructor is indicated by `operator=` because its an overloading of the `=` command.

The copy assignment constructor is *not* called in the following example.


```c++
Object new_obj = old_obj;
```

This is because its a declaration, and those are sent to the copy constructor. Had new_obj been already created - in another statement - it would call the `operator=` method.



```c++
class SpreadsheetCell
{
   public:
      SpreadsheetCell& operator=(const SpreadsheetCell& rhs);
      // Remainder of the class definition omitted for brevity
};
```

This returns a `reference` (unlike the copy constructor) so that it can be chained: `o1 = o2 = o3`.

Specifically, it has `    return *this;`.



```c++
myCell = anotherCell = aThirdCell;
//has the true form of 
myCell.operator=(anotherCell.operator=(aThirdCell));
//must guard against self assignment.
myCell=myCell 
//has weird effects if there are dynamic obj inside the obj.
SpreadsheetCell& SpreadsheetCell::operator=(const SpreadsheetCell& rhs)
{
   if (this == &rhs) {
      return *this;
   }
   //...
```

This works because `this` is actually a pointer to the object.  Likewise, `&rhs` is a reference.  Using the equality, we are actually comparing the value of the pointers - e.g. do they point to the same memory location, and are thus the same object. We return `*this` to de-reference the pointer and get the object itself.  This returns a reference to the object.

Explicit declaration or deletion is of the form below.

```c++
SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = default;
// or
SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = delete;
```

Returning an object, e.g. string, calls the copy constructor and passes an un-named obj back.  If on the other side you assign it to a string variable then its assignment operator is called.  So, two objects are temporarily created and destroyed. *Return Value Optimization* or *copy elision* tries to remove some of these inefficiencies.  


         Object obj(5);
         string s1 = obj.getString();

This calls the copy constructor for an un-named string, then calls the copy constructor for s1.  Not the assignment operator. A move constructor can also be used here and is more efficient.



#### Move Constructors
----

#### Initializer Lists
___

initializer-list constructor is a constructor with an `std::initializer_list<T>` as first parameter,
without any additional parameters or with additional parameters having default values. Before
you can use the `std::initializer_list<T>` template, you need to include the `<initializer_list>`
header.

The below example shows several things.  Throwing errors.  Vectors. and initializer lists.

```c++
#inclue <initializer_list>
#inclue <vector>
#...

class EvenSequence
{
   public:
      
      EvenSequence(initializer_list<double> args)  //pass a list of doubles named args
      {
         if (args.size() % 2 != 0) {
            throw invalid_argument("initializer_list should "
               "contain even number of elements.");
         } //requires it to be even ?pointless? maybe example of throw


         mSequence.reserve(args.size());  //get the size and reserve space.
         for (const auto& value : args) {
            mSequence.push_back(value); //push onto vector stack.
         }
         //could replace the for loop with
         mSequence.assign(args);
      }

      void dump() const
      {
         for (const auto& value : mSequence) {
            cout << value << ", ";
         }
         cout << endl;
      }

   private:
      vector<double> mSequence; //define vector.
};
```




---
### this keyword
---

```c++
void SpreadsheetCell::setValue(double value)
{
this->value = value;
}
```

a pointer to the object `this` is always passed to the method called.  `this` can be passed elsewhere, or used to disambiguate `value` above- which is both a data member and a function param.


```c++

//declared as a stand alone function:
void printCell(const SpreadsheetCell& cell)
{
   cout << cell.getString() << endl;
}

//in the object, pass a pointer to this.
void SpreadsheetCell::setValue(double value)
{
   this->value = value;
   printCell(*this);
}
```

!!!Warning Warning: When passing `this` elsewhere, make sure you pass the pointer `*this`.

      ALSO: Instead of writing a printCell() function, it would be more convenient
       to overload the << operator, as explained in Chapter 15. You can then use 
       the following line to print a SpreadsheetCell: 
            
               cout << *this << endl;

---
### Instantiation

---
#### Stack Instantiation
---


Space is reserved as soon as declared.  e.g. line 1.  Stack objects are destroyed as soon as they go out of scope (`{ }`).  This is why they don't need to be deleted.

```c++
SpreadsheetCell myCell, anotherCell;
myCell.setValue(6);
anotherCell.setString("3.2");
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;
```
These you can access methods and public data members with the access dot `.` operator. 

On the stack, assuming a constructor that takes an int:: `SpreadsheetCell::SpreadsheetCell(int n);` you can call it by just putting the params in the descriptor.

`SpreadsheetCell myCell(5), anotherCell (4);`


!!!Warning You cannot explicitly call the Constructor, also when creating an object on the stack, omit parentheses for the default constructor.
      ```c++
      SpreadsheetCell myCell.SpreadsheetCell(5); //wrong
      ```

      or call it later:

      ```c++
      SpreadsheetCell myCell;
      myCell.SpreadsheetCell(5);

      ```

      Also, for default constructors, this looks right:

      ```c++
      SpreadsheetCell myCell(); // WRONG, but will compile.
      myCell.setValue(6); //wont fail until <-here
      //it must be like this:
      SpreadsheetCell myCell;
      ```
      Do not use parens () when calling the default.  
      
      This problem is commonly known as *the most vexing parse,* and it means that your compiler thinks the first line is actually a function declaration for a function with the name myCell that takes zero arguments and returns a SpreadsheetCell object.







---
#### Heap Instantiation
---

Heap objects are not destroyed when they go out of scope.  If the pointer to it is declared in a scope and that scope closes, you lose the pointer, and thus access to the object which causes a memory leak.  Use smart pointers or use delete and nullptr.

Below space is not reserved until `new` or `make_unique` is called.  e.g. if you split the declaration and assignment below- you would have an indeterminate pointer which is bad, but also no space reserved.

```c++
SpreadsheetCell* myCellp = new SpreadsheetCell();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
" " << myCellp->getString() << endl;
delete myCellp;
myCellp = nullptr;
```

Objects on the heap need to be referenced with the **arrow** operator `->` which combines dereference `*` and member access `.`

You can use this other way instead like this `(*myCellp).getValue()` for `myCellp->getValue()`

Must call `delete` on these (and not required but good practice to set that pointer to nullptr- as delete follows the pointer to the object.  Once its gone, the pointer still points there.), or use smart pointers:


```c++
//C++11 style
unique_ptr<SpreadsheetCell> myCellP{make_unique<SpreadsheetCell>()}
//C++14 style
auto myCellp = make_unique<SpreadsheetCell>();
// Equivalent to:
unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
//<C++11 requires raw pointers.
// Or with raw pointers, without smart pointers (not recommended)
SpreadsheeCell* myCellp = new SpreadsheetCell();
SpreadsheetCell* myCellp = new SpreadsheetCell(5);
SpreadsheetCell* anotherCellp = nullptr;  //if not used immed. make `nullptr`
anotherCellp = new SpreadsheetCell(4);



delete myCellp;
myCellp = nullptr;

myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
" " << myCellp->getString() << endl;
```

These all are similar

```c++
//preC++11
SpreadsheetCell* myCellp = new SpreadsheetCell();
//AND
delete myCellp;
myCellp = nullptr;

//OR (C++14+)
auto myCellp = make_unique<SpreadsheetCell>();
//OR (C++11+)
unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
```

Using Heap constructors:

```c++
//C++14+
auto smartCellp = make_unique<SpreadsheetCell>(4);

// Or with raw pointers, without smart pointers (not recommended)
SpreadsheetCell* myCellp = new SpreadsheetCell(5);
SpreadsheetCell* anotherCellp = nullptr;  //if not used immed. make `nullptr`
anotherCellp = new SpreadsheetCell(4);

//after
delete myCellp; myCellp = nullptr; 
delete anotherCellp; anotherCellp = nullptr;

//default constrictor is same as the first example.
//Requires C++14+
auto smartCellp = make_unique<SpreadsheetCell>();
// Or with a raw pointer (not recommended)
//used pre-C++11
SpreadsheetCell* myCellp = new SpreadsheetCell();
```

generally: 

for C++ 14+

`auto [varName] = make_unique<[Class]> ( [ctor params] );`

for C++11+

`unique_ptr< [Class] > [varName] (new [Class]( [ctor params] ));`

for < C++ 11

`[Class]* [varName] = new [Class]( [ctor params] )`



### Inheritence

from a single parent class --- this is called simple inheritance or single inheritance

inherits from more than one direct parent class it is called multiple inheritance.
 



**Syntax**

```c++
class derived_class_name : [access] base_class_name
{
    … class member declarations & definitions …
};
```


#### Multiple Inheritance

 MULTIPLE INHERITANCE is one way of building new objects from libraries of existing objects without reinventing the wheel
 
 Multiple inheritance involves defining a derived class that directly inherits members from more than one base class
The syntax for defining a class using multiple inheritance is:

```c++
class derived_class_name : access1 base_class1 , ... ,  accessN base_classN 
{
... Class Members ...
}
```

Keywords

`derived`-  over-rides
`final` prevents over-riding.


```c++
// With C++11 "final" can be used to prevent inheritance
class MyClass final
{
    …
} ;
// This will generate a compilation error
class Derived : public MyClass
{
    …
};

```

```c++
#include    <iostream>
using namespace std;

class base1
{
    protected:      int d1;
    public:         void show_base1() { cout << "base1 data is " << d1 << " \n"; }
};

class base2
{
    protected:    int d2;
    public:        void show_base2() { cout << "base2 data is " << d2 << "\n"; }
};

class derived_class : public base1 , public base2
{
    private:    int d_data;
    public:
            void set_derived() { d_data = d1 + d2; }
            void set_base( int I, int j ) { d1 = I; d2 = j; }
            void display_derived() { cout << "d_data is " << d_data << endl; }
};

// PROGRAM OUTPUT:    d_data is 50

#include    "classes.h"

int main()
{
    derived_class myobj;

    myobj.set_base( 20,30 );
    myobj.set_derived();
    myobj.display_derived();

    return 0;
}

```



#### Inheritence vs Aggregation

**Inheritance** should be used when a class is needed that does everything an existing class does, but has some special features---in the Unified Modeling Language this is called *generalization/specialization*

   **Inheritance** models an "`is a`" relationship --- a child class object is a parent class object with some additional specialized characteristics;  The "is a" test is a reliable one/

**Aggregation** is used when you want to build classes that contain other classes as components.  Containment is a synonym for Aggregation.




The access status of the inherited members (public, private, or protected) is determined by the 'access' specified … if 'access' is not specified the default is private

`Public` - everything is the same from the Derived class to the Base class.  Public is public and Protected=protected and Private is Private, which means that the Private Values are private to the base class
 
| Base:  ->     | *Public*      | *Private*   | *Protected*   |
| ------------- | ------------- | ----------- | ------------- |
| Access        | Derived       | Derived     | Derived       |
| ------------- | ------------- | -------     | ---------     |
| **Public**    | **Public**    | **Private** | **Protected** |
| **Private**   | **Private**   | **Private** | **Private**   |
| **Protected** | **Protected** | **Private** | **Protected** |

!!!Caution Private inheritance is really rarely a good choice.  The better choice is containment over this.

*    Prefer using the strict encapsulation principle when implementing inheritance
*    Prefer using private data members vs. protected data members to preserve strict encapsulation
*    Make data members private & use protected member functions to allow derived classes access to base class data members




#include    <iostream>
using namespace std;
class base
{
    private:        int x;
    protected:    getX() { return x; }
    public:        base() { x = 99; }
            void display() { cout << "x is " << x << endl;}
} ;
class derived : public base
{
    private:    int y;
    public:    derived () { y = 88 + getX() ; } 
        …
};


```c++
#include    <iostream>
using namespace std;

class base_class
{
    private:    int x;
            int y;

    public:    base_class() { x = 0; y = 0; }
            void set_base_data( int , int );
            void display_base();
};

class derived_class : public base_class        // Specify inheritance
{
    private:    int d_data;
    public:    derived_class() { d_data = 0; }
            void set_derived_data( int );
            void display_derived();
};

// PROGRAM OUTPUT:    x is 22 : y is 33
//                    d_data is 10

int main()
{
    derived_class myobj;                // Declare a derived class object
    myobj.set_base_data( 22 , 33 );    // Access base class private data via 
                                    // public function
    myobj.display_base();                // Display base class data
    myobj.set_derived_data( 10 );        // Access derived class private data
    myobj.display_derived();            // Display derived class private data
    return 0;
}

```


```c++
// This program defines a derived class that does nothing but use the 
// inherited respond() function.

#include    <iostream>
using namespace std;

class robot
{
    public: void respond( char *s ) { cout << s << endl; }
};

class defiant_robot : public robot
{
    public:
};
// This program defines a derived class that does nothing but use the 
// inherited respond() function.
//
// PROGRAM OUTPUT:        Hello
//                        Whut!!


#include    "robots.h"

int main()
{
    robot r2d2;
    r2d2.respond("Hello");
    defiant_robot Butch;
    Butch.respond("Whut!!");        // subclass inherits respond()

    return 0;
}
// Program illustrating derived class overriding an inherited function
//
// The defiant_robot class overrides inherited respond() function by
// defining its own respond() function with identical signature
```

Derived Classes Override or Shadow the Inherited Members.

```c++
#include    <iostream>
using namespace std;

class robot
{
    public: void respond( char * s ) { cout << s << "\n"; }
};

class defiant_robot : public robot
{
    public: void respond( char * s ) { cout << "I Refuse \n"; }
};

```

____

### Base Class Pointers


____


### Interfaces




___

## Data structures

### Lists

(using vectors)

C++ vectors are very similar to Python lists, i.e. they provide containers for a list/array of values that can be accessed by their index. The big difference between Python lists and C++ vectors is that C++ vectors can only hold values of a single type, which must be specified when you create the vector. For example, create the source file vector.cpp and copy in the below code;

[chryswoods.com | Lists and Dictionaries](https://chryswoods.com/beginning_c++/lists.html)


### Vectors



### Dictionaries

(Using Map)

[chryswoods.com | Lists and Dictionaries](https://chryswoods.com/beginning_c++/lists.html)

Like Python, C++ has a great dictionary type, which in C++ is called a map. This is a container that stores values that are indexed by a key. C++ maps are less versatile than Python dictionaries as all of the keys have to be the same type, and all of the values have to be the same type. For example, copy the following into the source file map.cpp;


### Map

```C++ 
#include <iostream>
#include <map>
#include <string>

int main()
{
    //create a map that stores strings indexed by strings
    std::map<std::string, std::string> m;

    //add some items to the map
    m["cat"] = "mieow";
    m["dog"] = "woof";
    m["horse"] = "neigh";
    m["fish"] = "bubble";

    //now loop through all of the key-value pairs
    //in the map and print them out
    for ( auto item : m )
    {
        //item.first is the key
        std::cout << item.first << " goes ";

        //item.second is the value
        std::cout << item.second << std::endl;
    }

    //finally, look up the sound of a cat
    std::cout << "What is the sound of a cat? " << m["cat"] 
              << std::endl;

    return 0;
}
```


- You need to include the <map> header file as std::map<> is part of the C++ standard library.
- You must specify the type of the key and the type of the value, between the angle brackets, e.g. std::map<int,double> would be a map that uses integer keys to look up double values.
- Like Python, you look up items in the map using square brackets, e.g. m["cat"] looks up the value for "cat".
- Like Python, if the item doesn't exist, then it is created and assigned, e.g. m["cat"] = "mieow" sets the value associated with the key cat to mieow.
- Unlike Python, there is no .insert() function. You can only add items using lookup.
- Unlike Python, there is no .keys() or .values() function. You have to write these yourself…
- When you loop through the values in a map, the iterated item is a key-value pair. In for ( auto item : m ), the type of item is a key-value pair. The key is the first item in the pair item.first, while the value is the second item item.second.
- All keys in a map have to have the same type, and all values in a map have to have the same type, buy keys and values don't have to have the same type. For example, std::map<float,std::string> creates a map in which all keys are floats, and all values are strings.

```C++ 
    #include <iostream>
#include <string>
#include <map>
#include <vector>

int main()
{
    //declare the map that uses a person's name as a key, and looks
    //up a map that stores the person's weight and height
    std::map< std::string, std::map<std::string,float> > database;

    //let's first put the data in three vectors
    std::vector<std::string> names = { "James", "Jane", "Janet", "John" };
    std::vector<float> heights = { 1.7, 1.8, 1.5, 1.4 };
    std::vector<float> weights = { 75.4, 76.5, 56.8, 52.0 };

    //now put all of the data into the database
    for (int i=0; i<names.size(); ++i)
    {
        std::map<std::string,float> data;

        data["height"] = heights[i];
        data["weight"] = weights[i];

        database[names[i]] = data;
    }

    //now print out the entire database
    for ( auto item : database )
    {
        //print out the name
        std::cout << item.first << " : ";

        //now print out all of the data about the person
        for ( auto data : item.second )
        {
            std::cout << data.first << "=" << data.second << " ";
        }

        std::cout << std::endl;
    }

    return 0;
}
```



## Error Handling 




```c++
EvenSequence(initializer_list<double> args)
{
if (args.size() % 2 != 0) {
throw invalid_argument("initializer_list should "
"contain even number of elements.");
}
mSequence.assign(args);
}
//EvenSequence objects can be constructed as follows:
EvenSequence p1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
p1.dump();
try {
EvenSequence p2 = {1.0, 2.0, 3.0};
} catch (const invalid_argument& e) {
cout << e.what() << endl;
}
```

This is an example of a stack trace.

For Linux and I believe Mac OS X, if you're using gcc, or any compiler that uses glibc, you can use the `backtrace()` functions in _execinfo.h_ to print a stacktrace and exit gracefully when you get a segmentation fault. Documentation can be found in the libc manua

Here is a high level discussion on stacktraces: 

[c++ - How to automatically generate a stacktrace when my program crashes - Stack Overflow](https://stackoverflow.com/questions/77005/how-to-automatically-generate-a-stacktrace-when-my-program-crashes)


```C++ 
#include <stdio.h>
#include <execinfo.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>


void handler(int sig) {
  void *array[10];
  size_t size;

  // get void*'s for all entries on the stack
  size = backtrace(array, 10);

  // print out all the frames to stderr
  fprintf(stderr, "Error: signal %d:\n", sig);
  backtrace_symbols_fd(array, size, STDERR_FILENO);
  exit(1);
}

void baz() {
 int *foo = (int*)-1; // make a bad pointer
  printf("%d\n", *foo);       // causes segfault
}

void bar() { baz(); }
void foo() { bar(); }


int main(int argc, char **argv) {
  signal(SIGSEGV, handler);   // install our handler
  foo(); // this will call foo, bar, and baz.  baz segfaults.
}
```



### C library to handle signals

`<csignal>` `(signal.h)`


Functions

- `signal` - Set function to handle signal (function )
- `raise` - Generates a signal (function )

Types

- `sig_atomic_t` - Integral type (type )

Macro constants

- int (signals)
    - `SIGABRT` : **(Signal Abort)** - Abnormal termination, such as is initiated by the abort function.
    - `SIGFPE` : **(Signal Floating-Point Exception)** - Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
    - `SIGILL` : **(Signal Illegal Instruction)** - Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
    - `SIGINT` : **(Signal Interrupt)** - Interactive attention signal. Generally generated by the application user.
    - `SIGSEGV` : **(Signal Segmentation Violation)** - Invalid access to storage: When a program tries to read or write outside the memory it has allocated.
    - `SIGTERM` : **(Signal Terminate)** - Termination request sent to program.
functions (handlers)
    - `SIG_DFL` :  - Default handling: The signal is handled by the default action for that particular signal.
    - `SIG_IGN` :  - Ignore Signal: The signal is ignored.
    - `SIG_ERR` :  - Special return value indicating failure.


## IO Operations

![IO](http://www.cplusplus.com/img/iostream.gif)

[StringStream](https://stackoverflow.com/questions/2462951/c-equivalent-of-stringbuffer-stringbuilder)



```c++
#include <string>
#include <iosteam.h>
cout << "HELLO WORLD"
cin>>readVal

#include <sstream>
std::stringstream ss;
ss << "my data " << 42;
std::string myString( ss.str() );
//or  return ss.str();
```


___

## Setup (VS Code)
___
___

### Keybindings

```json
  {
    "key": "ctrl+alt+d z",
    "command": "editor.action.insertSnippet",
    "when": "editorTextFocus && editorLangId == 'cpp'",
    "args": {
      "name": "Debug2",
      "langId": "cpp",
      // "snippet": "helloo"
    }
  },
  {
    "key": "ctrl+alt+d x",
    "command": "editor.action.insertSnippet",
    "when": "editorTextFocus && editorLangId == 'cpp'",
    "args": {
      "name": "Debug NoLevel",
      "langId": "cpp",
      // "snippet": "helloo"
    }
  },
```

### Shortcuts

### Snippets

```json
    "Debug NoLevel": {
        "prefix": "dbg",
        "body": "if (DEBUG_EN) Serial.println(\"$1\");\n$0",
        "description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
    },
    "Debug": {
        "prefix": "dbglvl",
        "body": [
            "if (DEBUG_EN >= ${1: 1 , 2 , 3 , 4 } ) Serial.println(\"$2\");",
            "$0"
        ],
        "description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
    },
    "Debug2": {
        "prefix": "dbgdet",
        "body": [
            "if (DEBUG_EN) Serial.println(\"${1:$TM_CURRENT_WORD}, $TM_LINE_NUMBER:$TM_FILENAME = \" + $1);",
            "$0"
        ],
        "description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
    }
}
```

### Settings

```json

```


### Todo place me:


Functions
Operations on files:

- `remove` - Remove file (function )

- `rename` - Rename file (function )

- `tmpfile` - Open a temporary file (function )

- `tmpnam` - Generate temporary filename (function )


File access:

- `fclose` - Close file (function )

- `fflush` - Flush stream (function )

- `fopen` - Open file (function )

- `freopen` - Reopen stream with different file or mode (function )

- `setbuf` - Set stream buffer (function )

- `setvbuf` - Change stream buffering (function )


Formatted input/output:

- `fprintf` - Write formatted data to stream (function )

- `fscanf` - Read formatted data from stream (function )

- `printf` - Print formatted data to stdout (function )

- `scanf` - Read formatted data from stdin (function )

- `snprintf` - Write formatted output to sized buffer (function )

```C++ 
    /* snprintf example */
#include <stdio.h>

int main ()
{
  char buffer [100];
  int cx;

  cx = snprintf ( buffer, 100, "The half of %d is %d", 60, 60/2 );

  if (cx>=0 && cx<100)      // check returned value

    snprintf ( buffer+cx, 100-cx, ", and the half of that is %d.", 60/2/2 );

  puts (buffer);

  return 0;
}
```



- `sprintf` - Write formatted data to string (function )

```C++ 
    /* sprintf example */
#include <stdio.h>

int main ()
{
  char buffer [50];
  int n, a=5, b=3;
  n=sprintf (buffer, "%d plus %d is %d", a, b, a+b);
  printf ("[%s] is a string %d chars long\n",buffer,n);
  return 0;
}
```



- `sscanf` - Read formatted data from string (function )

- `vfprintf` - Write formatted data from variable argument list to stream (function )

- `vfscanf` - Read formatted data from stream into variable argument list (function )

- `vprintf` - Print formatted data from variable argument list to stdout (function )

- `vscanf` - Read formatted data into variable argument list (function )

- `vsnprintf` - Write formatted data from variable argument list to sized buffer (function )

- `vsprintf` - Write formatted data from variable argument list to string (function )

- `vsscanf` - Read formatted data from string into variable argument list (function )


Character input/output:

- `fgetc` - Get character from stream (function )

- `fgets` - Get string from stream (function )

- `fputc` - Write character to stream (function )

- `fputs` - Write string to stream (function )

- `getc` - Get character from stream (function )

- `getchar` - Get character from stdin (function )

- `gets` - Get string from stdin (function )

- `putc` - Write character to stream (function )

- `putchar` - Write character to stdout (function )

- `puts` - Write string to stdout (function )

- `ungetc` - Unget character from stream (function )


Direct input/output:

- `fread` - Read block of data from stream (function )

- `fwrite` - Write block of data to stream (function )


File positioning:

- `fgetpos` - Get current position in stream (function )

- `fseek` - Reposition stream position indicator (function )

- `fsetpos` - Set position indicator of stream (function )

- `ftell` - Get current position in stream (function )

- `rewind` - Set position of stream to the beginning (function )


Error-handling:

- `clearerr` - Clear error indicators (function )

- `feof` - Check end-of-file indicator (function )

- `ferror` - Check error indicator (function )

- `perror` - Print error message (function )


Macros

- `BUFSIZ` - Buffer size (constant )

- `EOF` - End-of-File (constant )

- `FILENAME_MAX` - Maximum length of file names (constant )

- `FOPEN_MAX` - Potential limit of simultaneous open streams (constant )

- `L_tmpnam` - Minimum length for temporary file name (constant )

- `NULL` - Null pointer (macro )

- `TMP_MAX` - Number of temporary files (constant )

Additionally: _IOFBF, _IOLBF, _IONBF (used with setvbuf)
and SEEK_CUR, SEEK_END and SEEK_SET (used with fseek).

Types

- `FILE` - Object containing information to control a stream (type )

- `fpos_t` - Object containing information to specify a position within a file (type )

- `size_t` - Unsigned integral type (type )


### c

/* strcat example */
#include <stdio.h>
#include <string.h>

int main ()
{
  char str[80];
  strcpy (str,"these ");
  strcat (str,"strings ");
  strcat (str,"are ");
  strcat (str,"concatenated.");
  puts (str);
  return 0;
}


### <cstring> (string.h)

C Strings
This header file defines several functions to manipulate C strings and arrays.

Functions
Copying:

- `memcpy`- Copy block of memory (function )
- `memmove`- Move block of memory (function )
- `strcpy`- Copy string (function )
- `strncpy`- Copy characters from string (function )

Concatenation:

- `strcat`- Concatenate strings (function )
- `strncat`- Append characters from string (function )

Comparison:

- `memcmp`- Compare two blocks of memory (function )
- `strcmp`- Compare two strings (function )
- `strcoll`- Compare two strings using locale (function )
- `strncmp`- Compare characters of two strings (function )
- `strxfrm`- Transform string using locale (function )

Searching:

- `memchr`- Locate character in block of memory (function )
- `strchr`- Locate first occurrence of character in string (function )
- `strcspn`- Get span until character in string (function )
- `strpbrk`- Locate characters in string (function )
- `strrchr`- Locate last occurrence of character in string (function )
- `strspn`- Get span of character set in string (function )
- `strstr`- Locate substring (function )
- `strtok`- Split string into tokens (function )

Other:

- `memset`- Fill block of memory (function )
- `strerror`- Get pointer to error message string (function )
- `strlen`- Get string length (function )

Macros

- `NULL`- Null pointer (macro )

Types

- `size_t`- Unsigned integral type (type )

<ctime> (time.h)
C Time Library
This header file contains definitions of functions to get and manipulate date and time information.

Functions
Time manipulation

- `clock`- Clock program (function )
- `difftime`- Return difference between two times (function )
- `mktime`- Convert tm structure to time_t (function )
- `time`- Get current time (function )

Conversion

- `asctime`- Convert tm structure to string (function )
- `ctime`- Convert time_t value to string (function )
- `gmtime`- Convert time_t to tm as UTC time (function )
- `localtime`- Convert time_t to tm as local time (function )
- `strftime`- Format time as string (function )

Macro constants

- `CLOCKS_PER_SEC`- Clock ticks per second (macro )
- `NULL`- Null pointer (macro )

types

- `clock_t`- Clock type (type )
- `size_t`- Unsigned integral type (type )
- `time_t`- Time type (type )
- `struct tm`- Time structure (type )


header
<cctype> (ctype.h)
Character handling functions

[<cctype> (ctype.h) - C++ Reference](https://www.cplusplus.com/reference/cctype/)

- `isalnum`- Check if character is alphanumeric (function )
- `isalpha`- Check if character is alphabetic (function )
- `isblank`- Check if character is blank (function )
- `iscntrl`- Check if character is a control character (function )
- `isdigit`- Check if character is decimal digit (function )
- `isgraph`- Check if character has graphical representation (function )
- `islower`- Check if character is lowercase letter (function )
- `isprint`- Check if character is printable (function )
- `ispunct`- Check if character is a punctuation character (function )
- `isspace`- Check if character is a white-space (function )
- `isupper`- Check if character is uppercase letter (function )
- `isxdigit`- Check if character is hexadecimal digit (function )
    
Character conversion functions
Two functions that convert between letter cases:

- `tolower`- Convert uppercase letter to lowercase (function )
toupper
    Convert lowercase letter to uppercase (function )


    <cstdlib> (stdlib.h)
C Standard General Utilities Library
This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.

Functions
String conversion

atof
    Convert string to double (function )

atoi
    Convert string to integer (function )

atol
    Convert string to long integer (function )

atoll
    Convert string to long long integer (function )

strtod
    Convert string to double (function )

strtof
    Convert string to float (function )

strtol
    Convert string to long integer (function )

strtold
    Convert string to long double (function )

strtoll
    Convert string to long long integer (function )

strtoul
    Convert string to unsigned long integer (function )

strtoull
    Convert string to unsigned long long integer (function )


Pseudo-random sequence generation

rand
    Generate random number (function )

srand
    Initialize random number generator (function )


Dynamic memory management

calloc
    Allocate and zero-initialize array (function )

free
    Deallocate memory block (function )

malloc
    Allocate memory block (function )

realloc
    Reallocate memory block (function )


Environment

abort
    Abort current process (function )

atexit
    Set function to be executed on exit (function )

at_quick_exit
    Set function to be executed on quick exit (function )

exit
    Terminate calling process (function )

getenv
    Get environment string (function )

quick_exit
    Terminate calling process quick (function )

system
    Execute system command (function )

_Exit
    Terminate calling process (function )


Searching and sorting

bsearch
    Binary search in array (function )

qsort
    Sort elements of array (function )


Integer arithmetics

abs
    Absolute value (function )

div
    Integral division (function )

labs
    Absolute value (function )

ldiv
    Integral division (function )

llabs
    Absolute value (function )

lldiv
    Integral division (function )


Multibyte characters

mblen
    Get length of multibyte character (function )

mbtowc
    Convert multibyte sequence to wide character (function )

wctomb
    Convert wide character to multibyte sequence (function )


Multibyte strings

mbstowcs
    Convert multibyte string to wide-character string (function )

wcstombs
    Convert wide-character string to multibyte string (function )


Macro constants

EXIT_FAILURE
    Failure termination code (macro )

EXIT_SUCCESS
    Success termination code (macro )

MB_CUR_MAX
    Maximum size of multibyte characters (macro )

NULL
    Null pointer (macro )

RAND_MAX
    Maximum value returned by rand (macro )


Types

div_t
    Structure returned by div (type )

ldiv_t
    Structure returned by ldiv (type )

lldiv_t
    Structure returned by lldiv (type )

size_t
    Unsigned integral type (type )

<cstring> (string.h)
C Strings
This header file defines several functions to manipulate C strings and arrays.

Functions
Copying:

memcpy
    Copy block of memory (function )

memmove
    Move block of memory (function )

strcpy
    Copy string (function )

strncpy
    Copy characters from string (function )


Concatenation:

strcat
    Concatenate strings (function )

strncat
    Append characters from string (function )


Comparison:

memcmp
    Compare two blocks of memory (function )

strcmp
    Compare two strings (function )

strcoll
    Compare two strings using locale (function )

strncmp
    Compare characters of two strings (function )

strxfrm
    Transform string using locale (function )


Searching:

memchr
    Locate character in block of memory (function )

strchr
    Locate first occurrence of character in string (function )

strcspn
    Get span until character in string (function )

strpbrk
    Locate characters in string (function )

strrchr
    Locate last occurrence of character in string (function )

strspn
    Get span of character set in string (function )

strstr
    Locate substring (function )

strtok
    Split string into tokens (function )


Other:

memset
    Fill block of memory (function )

strerror
    Get pointer to error message string (function )

strlen
    Get string length (function )


Macros

NULL
    Null pointer (macro )


Types

size_t
    Unsigned integral type (typ