# C ++ class




## Links

[Reference](https://en.cppreference.com/w/)
[Try this tutorial](https://msdn.microsoft.com/en-us/library/bb384843.aspx)
[Dr. GUI](https://msdn.microsoft.com/en-us/library/aa302304.aspx)
[C Language Reference | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/c-language/c-language-reference?view=vs-2017)
[C++ Language Reference | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=vs-2019)


## Archetypical Program


```cpp
// this is a format
#include <iostream>

/* Another comment format */

using namespace std;

int main(int argc, char* argv[]){
    cout << "Groovy Baby!" << "\n";
    
    }


```


header files no longer contain *.h




## Multiple Files

### Initial Prototype

```cpp
//#main.cpp

#include <iostream.h>
using namespace std;

void greetings(); //program func prototype

int main(){
   greetings();
   return 0;

}

void greetings(){ //program function definition
   cout << "Hello World!" << endl;
   return;
}
```

### Brokenout to multiple files

To separate files:

#### header

```cpp
//#greet.h
#ifndef GREET_H
#define GREET_H
//if not defined, define GREET_H- prevents multiple definitions
//only done in the header file.

#include <iostream.h>
using namespace std;

//include the prototype
void greetings(); //program func prototype

#endif
```

Header file includes:

- prototypes
- global constants
- template code
- struct defs
- class defs
- ifndef and def

do not `#include` a *.cpp, only `#include *.h`

#### Implementation

```cpp
//#greet.cpp
#include "greet.h" //use quotes for files found in cur dir


void greetings(){ //program function definition
   cout << "Hello World!" << endl;
   return;
}
```

`#include "greet.h" //use quotes for files found in cur dir` includes the header file for itself which releases the necessity of ordering the files in a particular order.

`#include <iostream.h>` is in the header, so not required for being included into **greet.cpp**

#### Main Revised

```cpp
//#main.cpp

#include <iostream.h>
//add the include
#include "greet.h" //use quotes for files found in cur dir

using namespace std;

//// void greetings(); //program func prototype
//=> moves to .h

int main(){
   greetings();
   return 0;

}

//// void greetings(){ //program function definition
////    cout << "Hello World!" << endl;
////    return;
//// }
```
## Compilation

Sinle File:
`g++ -W -Wall -s -pendantic-errors proq.cpp -o my_proq`

To multiple files:
`g++ -W -Wall -s -pendantic-errors treeFarm.cpp treeFarmFunctions.cpp -o my_proq`
`g++ -W -Wall -s -pendantic-errors *.cpp  -o my_proq`

### Pragmas:

[Pragma directives and the __pragma keyword | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2017)

The Microsoft C and C++ compilers recognize the following pragmas:
Table 1



- alloc_text
- auto_inline
- bss_seg
- check_stack
- code_seg
- comment
- component
- conform 1
- const_seg
- data_seg
- deprecated
- detect_mismatch
- fenv_access
- float_control
- fp_contract
- function
- hdrstop
- include_alias
- init_seg 1
- inline_depth
- inline_recursion
- intrinsic
- loop 1
- make_public
- managed
- message
- omp
- once
- optimize
- pack
- pointers_to_members 1
- pop_macro
- push_macro
- region, endregion
- runtime_checks
- section
- setlocale
- strict_gs_check
- unmanaged
- vtordisp 1
- warning

### Compiler Pre-Defined Macros

[Predefined macros | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017)
Standard predefined macros


The compiler supports these predefined macros specified by the ISO C99 and ISO C++17 standards.

    __cplusplus Defined as an integer literal value when the translation unit is compiled as C++. Otherwise, undefined.

    __DATE__ The compilation date of the current source file. The date is a constant length string literal of the form Mmm dd yyyy. The month name Mmm is the same as the abbreviated month name generated by the C Runtime Library (CRT) asctime function. The first character of date dd is a space if the value is less than 10. This macro is always defined.

    __FILE__ The name of the current source file. __FILE__ expands to a character string literal. To ensure that the full path to the file is displayed, use /FC (Full Path of Source Code File in Diagnostics). This macro is always defined.

    __LINE__ Defined as the integer line number in the current source file. The value of the __LINE__ macro can be changed by using a #line directive. This macro is always defined.

    __STDC__ Defined as 1 only when compiled as C and if the /Za compiler option is specified. Otherwise, undefined.

    __STDC_HOSTED__ Defined as 1 if the implementation is a hosted implementation, one that supports the entire required standard library. Otherwise, defined as 0.

    __STDCPP_THREADS__ Defined as 1 if and only if a program can have more than one thread of execution, and compiled as C++. Otherwise, undefined.

    __TIME__ The time of translation of the preprocessed translation unit. The time is a character string literal of the form hh:mm:ss, the same as the time returned by the CRT asctime function. This macro is always defined.

(Microsoft-specific predefined macros)[https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017#microsoft-specific-predefined-macros]

### Preprocessor operators

[Preprocessor operators | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=vs-2017)
 
[See also](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=vs-2017#see-also)
 
 Four preprocessor-specific operators are used in the context of the `#define` directive The stringizing, charizing, and token-pasting operators are discussed in the next three sections. For information on the `defined` operator, see [The #if, #elif, #else, and #endif directives](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2017).
 
 
 `#` [Stringizing operator (#)](https://docs.microsoft.com/en-us/cpp/preprocessor/stringizing-operator-hash?view=vs-2017) 
  - Causes the corresponding actual argument to be enclosed in double quotation marks
 
 `#@` [Charizing operator (#@)](https://docs.microsoft.com/en-us/cpp/preprocessor/charizing-operator-hash-at?view=vs-2017)
 
  - Causes the corresponding argument to be enclosed in single quotation marks and to be treated as a character (Microsoft-specific)
 
 `##` [Token-pasting operator (##)](https://docs.microsoft.com/en-us/cpp/preprocessor/token-pasting-operator-hash-hash?view=vs-2017)
  - allows tokens used as actual arguments to be concatenated to form other tokens
 
 `defined` [defined operator](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2017)
 
 Simplifies the writing of compound expressions in certain macro directives

### Preprocessor directives

[Preprocessor directives | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2017)

The preprocessor recognizes the following directives:


- #define 
[#define](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-define-directive-c-cpp?view=vs-2019) 

- #error
- #import
- #undef
- #elif
- #if
- #include
- #using
- #else
- #ifdef
- #line
- #endif
- #ifndef
- #pragma

[Preprocessor directives | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2019)


[#error](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-error-directive-c-cpp?view=vs-2019) 
[#import](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp?view=vs-2019) 
[#undef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-undef-directive-c-cpp?view=vs-2019) 
[#elif](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019) 
[#if](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019)
[#include](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=vs-2019)
[#using](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-using-directive-cpp?view=vs-2019) 
[#else](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019) 
[#ifdef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=vs-2019) 
[#line](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-line-directive-c-cpp?view=vs-2019) 
[#endif](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=vs-2019)
[#ifndef](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=vs-2019) 
[#pragma](https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019)


___

## Standard Libraries

___

- [Language Support
   - <cstddef>
   - <cstdlib>
   - <version>
   - <limits>
   - <climits>
   - <cfloat>
   - <cstdint>
   - <new>
   - <typeinfo>
   - <source_location>
   - <exception>
   - <initializer_list>
   - <compare>
   - <coroutine>
   - <csignal>
   - <csetjmp>
   - <cstdarg>
- Concepts
   - <concepts>
- Diagnostics
   - <stdexcept>
   - <cassert>
   - <cerrno>
   - <system_error>
- General utilities
   - <utility>
   - <memory>
   - <memory_resource>
   - <scoped_allocator>
   - <bitset>
   - <tuple>
   - <optional>
   - <any>
   - <variant>
   - <type_traits>
   - <ratio>
   - <chrono>
   - <typeindex>
   - <functional>
   - <stacktrace>
   - <ctime>
- Strings
   - <string>
   - <string_view>
   - <cstring>
   - <charconv>
   - <format>
   - <cctype>
   - <cwctype>
   - <cwchar>
   - <cuchar>
- Localization
   - <locale>
   - <codecvt>
   - <clocale>
- Containers
   - <span>
   - <array>
   - <vector>
   - <deque>
   - <forward_list>
   - <list>
   - <map>
   - <set>
   - <queue>
   - <unordered_map>
   - <unordered_set>
   - <stack>
- Iterators
   - <iterator>
- Ranges
   - <ranges>
- Algorithms
   - <algorithm>
   - <execution>
- Numerics
   - <complex>
   - <random>
   - <valarray>
   - <numeric>
   - <bit>
   - <numbers>
   - <cfenv>
   - <cmath>
- Input/Output
   - <iosfwd>
   - <ios>
   - <iomanip>
   - <streambuf>
   - <istream>
   - <ostream>
   - <iostream>
   - <sstream>
   - <fstream>
   - <syncstream>
   - <cstdio>
   - <cinttypes>
   - <strstream>
- Regular expressions
   - <regex>
- Filesystem support
   - <filesystem>
- Thread support
   - <thread>
   - <atomic>
   - <mutex>
   - <shared_mutex>
   - <condition_variable>
   - <future>
   - <stop_token>
   - <semaphore>
   - <latch>
   - <barrier>
- C compatibility
   - <ciso646>
   - <cstdalign>
   - <cstdbool>
   - <ccomplex>
   - <ctgmath>
   - <stdatomic.h>



## Archetypical Program


```cpp
// this is a format
#include <iostream>

/* Another comment format */

using namespace std;

int main(){
    cout << "Groovy Baby!" << "\n";
    
    return 0;
    }

int main()
{
	int x;		// This is a C++ style comment

	// Each comment line is preceded by slashes
	// This is another comment line

	/* C++ also supports C-Style comments */

	return 0;
}

```

header files no longer contain *.h

```cpp
#include <cstdlib>	// was <stdlib.h>
#include <cstring>	// was <string.h>
                      // char* functions from C
#include <string>     // C++ string class
```


## include
!!!Warning:  Note: If you are using the Microsoft Visual C++ IDE, you will notice that by default, all source files start as follows:
      `#include "stdafx.h"`
    In a VC++ project, by default, every source file should start with this line, and your own include files must follow this. If you place your own include file before `stdafx.h`, they will appear to have no effect and you will get all kinds of compilation errors. This situation involves the concept of precompiled header files, which is outside the scope of this book. Consult the Microsoft documentation on precompiled header files to learn the details.

## Reserved Keywords

//42



## C++ Operators

You can also just use keywords instead of chars to make more readable program

| Operator    | Operator Keyword | Description                     |
| ----------- | ---------------- | ------------------------------- |
| Logical    |                  |                                 |
| &&          | and              | logical AND                     |
| \|\|        | or               | logical OR                      |
| !           | not              | logical NOT                     |
| Inequality |                  |                                 |
| !=          | not_eq           | inequality                      |
| Bitwise    |                  |                                 |
| &           | bitand           | bitwise AND                     |
| \|          | bitor            | bitwise OR                      |
| ^           | xor              | bitwise exclusive OR            |
| ~           | compl            | bitwise complement              |
| Bitwise Op  |                  |                                 |
| &=          | and_eq           | bitwise AND assignment          |
| \|=         | or_eq            | bitwise inclusive OR assignment |
| ^=          | xor_eq           | bitwise exclusive OR assignment |


```cpp
// Program to demonstrate "and" operator keyword
//
// Some compilers require inclusion of special header files

#include	<iostream>
#include	<iso646.h>		// Required for Visual C++ 6.0
using namespace std;

int main()
{
	int x = 8;
	int y;

	cout << "Enter an integer: ";
	cin >> y;

	if ( (x > 0) && (y > 0) )   cout << "Both greater than 0 \n";

	if ( (x > 0) and (y > 0 ) ) cout << "Same thing \n";

	return 0;
}
```

### Operator Precedence

[Operator Pref](http://en.cppreference.com/w/cpp/language/operator_precedence)


## Stdin and Std Out

`<<` insertion operator 
`>>` extraction operator

These can be chained.

C++ uses the standard input stream cin and the standard output stream cout

`#include <cstdlib>`
`#include <iostream>`


An example of stdin and out vs. C.

```cpp
#include	<iostream>	// Header file defining standard C++ I/O 
#include	<stdio.h>		// Old C language header now deprecated
using namespace std;
int main()
{
	int x = 0;

	/* The old C way */

	printf( “Please enter an integer: “ );
	scanf( “%d”, &x );
	printf( “You entered %d \n”, x );

	// The C++ way

	cout << “Please enter an integer: “;
	cin >> x;
	cout << “You entered “ << x << endl;
	cout << “x plus 2 is “;
	cout << x + 2 << endl;
	
	return 0;
}
```

```cpp
// Program Input:	10	20
//		30
//
// Program Output:	You entered: 10 20 30

#include	<iostream>
using namespace std;
int main()
{
	int x, y, z;

	cout << "enter 3 integers: ";
	cin >> x >> y >> z;		// whitespace delimits numeric input objects

	cout << "You entered: " << x << " " << y << " " << z << endl;

	return 0;
}
```

### Stream Manipulators

`#include <iomanip>`

Stream manipulators may be parameterized or non-parameterized
Must include the header file iomanip to use parameterized manipulators

showpoint
noshowpoint
setw(n)
boolalpha
setprecision(3) 
scientific
fixed


```cpp
#include	<iostream>
#include	<iomanip>		// Required for parameterized manipulators
#define	dbln	"\n\n”	// Symbolic constant prints 2 newlines

using	namespace	std;

int main()
{
	float v = 2.19512567f;
	float c = 4.f;
	
	cout << v << endl;
	cout << c << dbln;

	cout << showpoint << v << endl;	// showpoint forces dec & 0’s
	cout << c << dbln;

	cout << noshowpoint << c << dbln;	// reinstate default

	cout << setw(10) << v << endl;	// set field width to 10
	cout << c << dbln;

	return 0;
}

// Program to illustrate stream manipulators
//
// Program Output:	2.19513
//		4
//
//		2.19513
//		4.00000
//
//		4
//
//		   2.19513
//		4



#include	<iostream>
#include	<iomanip>
#define	dbln	"\n\n"
using	namespace	std;

int main()
{
	bool	b = true;
	float	f = 3.14159f;

	cout << b << endl;
	cout << boolalpha << b << dbln;

	cout << f << endl;
	cout << scientific << setprecision(3) << f << endl;
	cout << fixed << f << dbln;

	return 0;
}

// Program to demonstrate stream manipulators
//
// Program Output:	1
//		true
//
//		3.14159
//		3.142e+000
//		3.142
```

## Types

short - 2bytes -32,000-32000
unsigned short - 64000
int - could be 2 or 4 bytes (short or long)
long 4 bytes 2^32
float
double
long doubles
chars `' '` (Single quotes)
string `" "` (Double quotes)
bool 



**character** - `char` - Used to hold a single character of information.  Always requires a single byte of storage.

**integer** - `int` - Used to hold a signed whole number quantity.

**short integer** - `short` - Used to hold a signed whole number quantity.  Typically only requires half the storage requirements of a signed integer.

**long integer** - `long` - Used to hold a signed whole number quantity.  Typically requires twice as much storage as a normal signed integer.

**unsigned integer** - `unsigned` - Used to hold non-negative whole number quantities.

**floating point** - `float` - Used to hold signed numbers with fractional components.


**double precision** - `double` - Used to hold signed numbers with fractional components.  Typically requires twice the storage as a float.


**extended precision** - `long double` - Extended precision for floating point types.  Implemented as part of ISO/ANSI standard.

**boolean** - `bool` - Used to hold literal values true and false.

**constant** - `const` - Used to hold a constant value that cannot be changed during program execution.



**long long integer** - `long long` - Range is at least the same as long, but varies with compiler.

**unsigned long long integer** - `unsigned long long` - Extended range unsigned integer.

**16-bit character** - `char16_t` - A single 16-bit character.


**32-bit character** - `char32_t` - A single 32-bit character.


**automatic** - `auto` - The compiler will decide the type automatically.


**decltype** - `decltype( expr )` - The compiler determines the type of the expression expr. Useful for use with templates.


bool types can be used to create state variables that indicate truth or falsity
bool variables can be assigned the literal values true and false
The default value of a bool type is false


### Strings


`std::string_view` - C++17 - you can replace `std::string_view` with `const std::string&`. String_view is just a wrapper for a pointer and a length.

### Type Inference & Alternative Function Syntax 

C++ 11

Compiler deduces type at compile time

`auto` keyword.

```cpp
auto x = 99; 		

auto value = myFunc();


// Alternative Function Syntax … most useful when using
// templates


//function myfunc takes an int and returns an int, using below.  

//is this a lambda
auto myFunc( int x ) -> int
{
	return 2*x;
}


// Ask the compiler to figure out return type … most useful
// when using templates

auto myFunc( float v1, float v2 )
{
	return v1 * v2;
}

```
## Pointers


### Passing Objects

The best way is to provide the myGLCD object as a parameter to the constructor:

```cpp
touchButton::touchButton(UTFT &glcddev, int x, int y, int xs, int ys, char myuse) {
  x1 = x;
  y1 = y;
  xsize = xs;
  ysize = ys;
  use = myuse;
  glcd = &glcddev;
}
```

Then in your header you provide a:
```cpp
private: 
  UTFT *glcd;
Your library code then uses the glcd pointer to the object:

**glcd->drawRoundedRectangle(...);**
``` 

Note the use of `->` since glcd is a pointer to the object (as created by the & operator when it was assigned in the constructor).



## Enums

```cpp
enum PieceType(PieceTypeKing, PieceTypeQueen, PieceTypeRook);
```

Creates an enum, just carries the numerical int value of position. 
You can also specify values-


```cpp
enum PieceType(PieceTypeKing = 2, PieceTypeQueen, PieceTypeRook=10, PieceTypeKnight);
```

The values following will just be incremented.  e.g. King = 2, Q=3 R=10, K=11.

### Strongly Typed Enums

The above always has the value given underneath.  This allows you (perhaps inappropriately) to compare two unrelated *enums*.

To prevent that- use strongly typed ones.

this is the type safe version.


```cpp
enum class PieceType
{
   King=1,
   Queen,
   Rook,
   Pawn
};
```

For an enum class, the enumeration value names are not automatically exported to the enclosing scope, which means that you always have to use the scope resolution operator:


`PieceType piece = PieceType::King;`

These do not have underlying integer values, assigning numbers like above is an error.

`if(PieceType::Queen==1){} //error`


```cpp
enum class PieceType : unsigned long
{
   King = 1,
   Queen,
   Rook = 10,
   Pawn
};
```

### Iterable Enums



[How to iterate over enums](https://stackoverflow.com/questions/261963/how-can-i-iterate-over-an-enum)


Iterable Enums

```cpp
num Foo {
  One,
  Two,
  Three,
  Last
};

for ( int fooInt = One; fooInt != Last; fooInt++ )
{
   Foo foo = static_cast<Foo>(fooInt);
   // ...
}
``` 

```cpp
#include <iostream>
#include <algorithm>

namespace MyEnum
{
  enum Type
  {
    a = 100,
    b = 220,
    c = -1
  };

  static const Type All[] = { a, b, c };
}

void fun( const MyEnum::Type e )
{
  std::cout << e << std::endl;
}

int main()
{
  // all
  for ( const auto e : MyEnum::All )
    fun( e );

  // some
  for ( const auto e : { MyEnum::a, MyEnum::b } )
    fun( e );

  // all
  std::for_each( std::begin( MyEnum::All ), std::end( MyEnum::All ), fun );

  return 0;
}
```


## Structs

Binds types into a new type.  Structs are the same as classes, but all items are public.

```cpp
struct Car{

   int year;
   int miles;
   std::string make;
   int getValue() const;
}

struct SpreadsheetCell
{
      void setValue(double inValue);
      double getValue() const;
   private: //can have methods and private members
      double mValue;
};
```

You declare a car by just defining it: `Car car;`

Then access each value with the `.` operator.

### typedef

Using `typedef` on a `struct` defines it for external linkage.


`typedef struct { /* ... */ } S;`

---
---
## Control
---
- Iteration constructs
   - for
   - while
   - do-while
   - 'enhanced' for (C++ 11)
- Decision constructs
   - if-else
   - switch
   - conditional
- Other constructs
   - goto
   - break - used with switch.
   - continue - can be high risk

!!! question continue - said hed make a comment if used.

## Variables

- Variable names must begin with a letter or an underscore…remaining characters in a may be letters, digits or underscores
   - Avoid beginning names with single or double underscores
- Upper & lowercase letters are distinct
- All characters in a variable name are significant
- Must be declared, can be anywhere.

```cpp
#include	<iostream>
using namespace std;
int main()
{
	int a;		// value of a is undefined
	int b = 10;
	cout << b << endl;
	int z = 99;	// can’t do this in C language, but OK in C++
	cout << z << endl;

	for( int j = 0; j < 3; j++ )		// scope of j is for loop
	{
		cout << “j is “ << j << endl;
	}

	return 0;
}
```

### Initialization


int valueX; // this could be anything, whatever happens to be in the reused memory function
Copy Initialization: `int valueX = 0; `
Direct Initialization: `int valueX(0);`
Uniform Initialization (aka Brace Initialization): `int valueX{0};`
   - Zero Initialization: `int valueX{}` - initializes to zero or empty depending on value.

int valueX[0] returns a pointer, because this is actually a c-style array.

Using bracket assignment- it will warn about truncation.

eg `int x = 3.14` - x = 3

```cpp
int hamburgers = {16};	// set hamburgers to 16
int hotdogs {3};		// set hotdogs to 3
int mustard {};		// set mustard to 0
int relish = {};		// set relish to 0
int ketchup(1);		// set ketchup to 1

long double x = 3.14159;
int a{x}, b = {x};		// truncation error
int c(x), d = x;		// ok – but will truncate.  Using these assingment methods wont have checking.
int a =3;
int b{3};
int c = {3};
int d(3);
```

Uniform initialization (using `{}`) calls the default initializer for each item.  Especially for `0` initialization.  Primitive int and non float chars are 0, all floating pt values 0.0, and pointer values are `nullptr`

It prevents narrowing.

```cpp
void func(int i){/* */}

int x = 3.14 //auto narrows to 3.
func(3.14); //passes 3 automatically
//these may result in a compiler error for narrowing.

int x{3.14} //error
int x = {3.14} //error
func{(3.14)} //error

```

### List Initialization

There is a difference with Copy `=` and Direct Initilization in C++17

#### Direct List Initialization

`T obj {arg1, arg2, ...}`

```cpp
auto a {11}; //int

auto b {11, 22}; //Error - no list one element allowed
```

#### Copy List Initialization

`T obj = {arg1, arg2, ...}`

```cpp
auto a = {11}; //initilizer list<int>

auto b = {11, 22}; //initilizer list<int>
auto c = {11, 22.2} //ERROR must be same type
```

### Scoping

`static` keyword- allocates memory in .data segment at compile time, is loaded at execution and remains in memory for the duration.

//to do week 2

`inline` 

`extern` - used to declare an object without defining it.  States that it is defined elsewhere in the Linkage units- e.g. in another file.

      `extern int n;` - ok 
      `extern int n = 0;` not ok.

      To define you need:

      `extern const int n = 0`
#### namespaces

### Casting

`sstatic_cast<T>(v);`

Assigning a value to increasing precision is ok

eg. a float -> double

to force a cast to lower precision (e.g. double assigned to int)





```cpp
int intVal;
double dbVal1, dbVal2;
intVal = dbVal1 + dbVal2; //Causes error
intval = static_cast<int>(dbVal1 + dbVal2);
```

### Type Promotion

int integer
float flt

flt + integer = float 
flt - integer = float 
flt * integer = float 
flt / integer = float 
int / float = int
float % int = error
int % float = error **

Only int % int is allowed.


## Constants

- Literal constants are values that appear in a program (e.g. 33, 12.99, ‘A’, “Hello”)
- Literal constants are not addressable - Can’t directly address memory where value is stored
- Every literal constant has an associated type

Literal integer constants are treated as signed values of type int


      34		// decimal notation
      036		// octal
      0x14		// hexadecimal
      128L		// long (could also use l )
      128U		// unsigned (could also use u )
      14UL		// long unsigned
      14LL		// long long*
      128ULL		// unsigned long long*
      3.14159F	// float (could also use f )
      0.0		// double (default type)
      7.435L		// extended precision
      4e2		// scientific notation 
      2.35E-2	// scientific notation

f = F = float.

Printable literal character constants written with character inside single quotes


      ‘G’		// letter G
      ‘,’		// literal comma
      ‘ ‘		// literal blank
      ‘5’		// literal 5

Nonprintable characters, the single & double quote marks, and the backslash are represented using escape sequences

      \n		// newline
      \b	// backspace
      \t		// horizontal tab		
      \v	// vertical tab
      \r		// carriage return	
      \f	// formfeed
      \a		// alert (bell)		
      \\	// backslash
      \’		// single quote		
      \”	// double quote

Can also use \xxx where xxx is a sequence of up to 3 octal digits

		\0	// null			
      \7	// bell
		\14	// newline		
      \062	// ‘2’


Can be used to transform a variable into an addressable constant
Must be initialized in its declaration


const float pi = 3.14159;	// pi is a constant
const int c;		// ERROR!! must be initialized in declaration
pi = 22.3;		// ERROR!! can’t change value


### String Literals

String literals consist of zero or more characters enclosed in double quotes. Compiler adds terminating null character
Treated as an array of constant (const) characters
Nonprintable characters are represented by their escape sequences
		“”			// null string
		“A”			// not same as char literal ‘A’
		“Hello”		// String literal
		“Hello \t World”	// Embedded escape sequence
		“Multiple line \	// Can extend for several lines
		literal”		// using a backslash as the 
					// last character on a line

### Boolean literals

      true, false


## Complex Types


arrays, structures (type struct), unions (type union), and enumerators (type enum) are legacy types from C
C++ structures can have functions as well as data types as members
The class type will be discussed later in this course


### array

An  Array name is a special pointer, its a fixed pointer.  You can add to the array.

`
int[] array = {1...4}
`pos = array + 1;`

However you cannot reassign the array or start of the array.

`array +=1; //error`

### structure

You define struct names at the end:

```cpp
   #include <string>

    typedef struct {
        string valueName;
        long long value;
    } values;
```


### class

### union

### enumerator


47-84, 114-134

### Vectors

[See Initializer Lists for examples](#Initializer Lists)


```cpp
vector<double> mSequence;
std::vector<std::string> myVec = {"String 1", "String 2", "String 3"};
std::vector<std::string> myVec;
myVec.push_back("String 1");
myVec.push_back("String 2");
myVec.push_back("String 3");
mSequence.assign(args);
```



## Strings

endl

//38
//39


Using a string manipulator

```cpp
//40
// Program to read and display a line of input
//
// Program Input:	That’s better
//
// Program Output:	You entered: That’s better

#include	<iostream>
using namespace std;
int main()
{
	char line[81];
	char c;
	int i = 0;

	cin >> noskipws;		// use manipulator to recognize whitespace

	cout << "Please enter a line of text: ";

	while ( ( cin >> c ) && ( c != '\n' ) )
		line[i++] = c;

	line[i] = '\0';

	cout << "\n\nYou entered: " << line << endl;
	return 0;
}
```

## Mixing Input Types

//41

## Functions

- Two basic types of functions
   - Ordinary functions --- like in C
   - Class member functions --- used in O-O programs
- A function definition (i.e., its code) or a function prototype must appear in the code before the function is invoked
- Normal practice is to use function prototypes
- Functions may have arguments & may return a value

//46

Functions need to appear before they are used, so a protoype has to occur.

```cpp
#include	<iostream>
using namespace std;


//function prototypes
void print_message();		// A function prototype
float product( int , float ); // Another prototype

			void main()
			{
				float k = 13.54f;
				float num = 43.77f;

				print_message();		// Invoking functions
				cout << product( k , num );
			}

			// Function definitions

void print_message()
			{
				cout << "Where's the Beef?" << " \n";
			}

			float product ( int c , float f )
			{
				return ( c * f );
			}
```

Typically placed at top of source file or “included” via a pre-processor directive

When placed outside of a function scope is from point of placement to end of source file

When placed inside a function scope is from point of placement to end of function

```cpp

#include	<iostream>
using namespace std;

void myfunc();		// Scope is source file
void message();

void main()
{
	message();
	myfunc();
}

void myfunc()
{
	int afunc();	// Scope is myfunc()

	message();
	cout << afunc();
}

int afunc() { return 99; }

void message() { cout << “HELLO \n”; }

```

### Passing Arguments and Returning

//49

//50

### Using const With Function Arguments

If a value passed as a function argument should not be altered in the function, the argument should be declared as `const`

The C++ compiler will not allow const arguments to be modified by a function


```cpp
// Function taking const argument

void myfunc( int arg1, const int arg2 )
{
	arg1 = 2*arg1;		// OK
	arg2 += arg1;		// ERROR --- can’t change arg2
}
```

___
## Classes 
---


```cpp
class SpreadsheetCell
{
// Remainder of the class definition omitted for brevity
private:
double mValue = 0;
};


<in class.cpp>
#include "SpreadsheetCell.h"

void SpreadsheetCell::setValue(double inValue)
{
   mValue = inValue;
}

double SpreadsheetCell::getValue() const  //use const when values arent changing
{
   return mValue;
}
```

```cpp
// in header file
class touchButton {
  public:
    touchButton(int x, int y, int xs, int ys, char use);
    void Draw();
    int x1;
    int y1;
    int xsize;
    int ysize;
    char use;
    boolean toggle = false;
};

```


```cpp
//in body
  touchButton::touchButton(int x, int y, int xs, int ys, char myuse) {
    x1 = x;
    y1 = y;
    xsize = xs;
    ysize = ys;
    use = myuse;
  }

  void touchButton::Draw() {
    switch (use) {
      case 'p':
      //this is what I would like to have called from the main file.
      //myGLCD.drawRoundRect(x1, y1, x1+xsize, y1+ysize);
        break;

       default:
        break;
    }
  }

  ```


### Brief assignment
---

   `CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}`
   

### Uniform Initialization
---

Structs and classes can be initiated similarly

```cpp

stuct CircleStruct{
   int x,y ;
   double radius;
}
class CircleClass{
   public:
   CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}

}
CircleStruct myCircle = {10, 10, 2.5}
CircleStruct myCircle4{10, 10, 2.5}
CircleClass myCircle2{10, 10, 2.5};
CircleClass myCircle3 = {10, 10, 2.5};
```

Objects are created at the point you declare them (if they’re on the stack) or when you explicitly allocate space for them with `new`, `new[]`, or a *smart pointer*.

---
### Constructors
---

!!!NOTE C++ programmers sometimes call a constructor a ctor.

You cannot declare a constructor in terms of another:


```cpp
SpreadsheetCell::SpreadsheetCell(string_view initialValue)
{
      SpreadsheetCell(stringToDouble(initialValue));
}
```

The code will compile, link, and run, but will not do what you expect. It creates a temp object then dumps it on return. You can use **Delegate constructors**
?Can you return it?

Default constructors are needed - a constructor with 0 params- especially **if the object may be used in an array**.  A default constructor is also required for classes that you want to store in Standard Library containers, such as `std::vector`.


```cpp
SpreadsheetCell cells[3]; // FAILS compilation without default constructor
SpreadsheetCell* myCellp = new SpreadsheetCell[10]; // Also FAILS
```

You can circumvent this restriction for stack-based arrays by using initializers like these:

```cpp
SpreadsheetCell cells[3] = {SpreadsheetCell(0), SpreadsheetCell(23),
**SpreadsheetCell(41)};**
```

There is an *implicit* default constructor, unless an explicit constructor is defined.  Then you need to explicitly declare the default if you want it available.  If you explicitly don't want a default constructor, and have no others, you need to explicitly delete it.


```cpp
class MyClass
{
public:
   MyClass() = default;
   MyClass(double initialValue);
   MyClass(std::string_view initialValue);

   //explicit deletion of default.  No constructor.
public:
   MyClass() = delete;
};
```

---
#### Constructor Initializers
---


```cpp
SpreadsheetCell::SpreadsheetCell(double initialValue): mValue(initialValue){}
```

Each element in the list is an initialization of a data member using function notation or the uniform initialization syntax, a call to a base class constructor (see Chapter 10), or a call to a delegated constructor, which is discussed later.

The initializer list is of format `:` then a comma separated list.



```cpp
class SpreadsheetCell
{
   public:
      SpreadsheetCell(double d);
};

class SomeClass
{
   public:
      SomeClass();
   private:
      SpreadsheetCell mCell; //no value assigned, and no default
}; 

SomeClass::SomeClass() { } //err

SomeClass::SomeClass() : mCell(1.0) { } //now works/
```

!!!Warning ctor-initializers initialize data members in the order that they appear in the class definition, not their order in the ctor-initializer.


#### Copy Constructors

Will be created by default, unless you explicitly delete or declare a new one.  But the general form is here:

1. When a class object is created and initialized with an existing object of the class.
2. When a class object is passed by value as a function arg.
3. When a class is returned from a function.

This is (the default version) us a shallow copy

This is ok if the class only has primitive types as members or if the class does not have any pointers or reference types.

-if there is a pointer in the object, then copying object 1 to object 2, affecting object 1 will affect object 2 (if there is a pointer `int* a` for instance both objects point to the same `int * a`)                                                         



```cpp
SpreadsheetCell(const SpreadsheetCell& src);
SpreadsheetCell(const SpreadsheetCell src); //doing this causes infinitate recursion- because it calls copy constructor here- to copy input to src...
// used like this in implementation
SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src)
: mValue(src.mValue)
{
}
```

!!!Info Info: This is important because C++ is pass by Value, so by default Objects are copied before passing to functions or methods.

If **either** the `Copy` or `Copy Assignment` constructor or destructor is declared, the other *will not* be (given a default).

To add it back:


```cpp
MyClass(const MyClass& src) = default;

MyClass& operator=(const MyClass& rhs) = default;
```




Utilizing the copy constructor:

```cpp
MyClass myClass(params);
MyClass copyClass(myClass);
```

where possible, pass by `const reference`.  Returning by Reference can be risky.  E.g. if you create a string in a method, and then return it by reference to avoid copying, the address  will be returned, but the underlying string will be dumped.

Explicitly declare or remove the copy constructor (e.g. you dont want an object copied.) This can be used to disallow passing the object by value,

```cpp
SpreadsheetCell(const SpreadsheetCell& src) = default;
SpreadsheetCell(const SpreadsheetCell& src) = delete;1
```

#### Copy assignment 

Works by setting one, existing object to entirely match the other.

```
Object o(params);
Object oo(params);
oo=o;
```

At the end both still exist, just oo matches o.  

This constructor is indicated by `operator=` because its an overloading of the `=` command.

The copy assignment constructor is *not* called in the following example.


```cpp
Object new_obj = old_obj;
```

This is because its a declaration, and those are sent to the copy constructor. Had new_obj been already created - in another statement - it would call the `operator=` method.



```cpp
class SpreadsheetCell
{
   public:
      SpreadsheetCell& operator=(const SpreadsheetCell& rhs);
      // Remainder of the class definition omitted for brevity
};
```

This returns a `reference` (unlike the copy constructor) so that it can be chained: `o1 = o2 = o3`



```cpp
myCell = anotherCell = aThirdCell;
//has the true form of 
myCell.operator=(anotherCell.operator=(aThirdCell));
//must guard against self assignment.
myCell=myCell 
//has weird effects if there are dynamic obj inside the obj.
SpreadsheetCell& SpreadsheetCell::operator=(const SpreadsheetCell& rhs)
{
   if (this == &rhs) {
      return *this;
   }
   //...
```

This works because `this` is actually a pointer to the object.  Likewise, `&rhs` is a reference.  Using the equality, we are actually comparing the value of the pointers - e.g. do they point to the same memory location, and are thus the same object. We return `*this` to de-reference the pointer and get the object itself.  This returns a reference to the object.

Explicit declaration or deletion is of the form below.

```cpp
SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = default;
// or
SpreadsheetCell& operator=(const SpreadsheetCell& rhs) = delete;
```

Returning an object, e.g. string, calls the copy constructor and passes an un-named obj back.  If on the other side you assign it to a string variable then its assignment operator is called.  So, two objects are temporarily created and destroyed. *Return Value Optimization* or *copy elision* tries to remove some of these inefficiencies.  


         Object obj(5);
         string s1 = obj.getString();

This calls the copy constructor for an un-named string, then calls the copy constructor for s1.  Not the assignment operator. A move constructor can also be used here and is more efficient.



#### Move Constructors
----

#### Initializer Lists
___

initializer-list constructor is a constructor with an `std::initializer_list<T>` as first parameter,
without any additional parameters or with additional parameters having default values. Before
you can use the `std::initializer_list<T>` template, you need to include the `<initializer_list>`
header.

The below example shows several things.  Throwing errors.  Vectors. and initializer lists.

```cpp
#inclue <initializer_list>
#inclue <vector>
#...

class EvenSequence
{
   public:
      
      EvenSequence(initializer_list<double> args)  //pass a list of doubles named args
      {
         if (args.size() % 2 != 0) {
            throw invalid_argument("initializer_list should "
               "contain even number of elements.");
         } //requires it to be even ?pointless? maybe example of throw


         mSequence.reserve(args.size());  //get the size and reserve space.
         for (const auto& value : args) {
            mSequence.push_back(value); //push onto vector stack.
         }
         //could replace the for loop with
         mSequence.assign(args);
      }

      void dump() const
      {
         for (const auto& value : mSequence) {
            cout << value << ", ";
         }
         cout << endl;
      }

   private:
      vector<double> mSequence; //define vector.
};
```




---
### this keyword
---

```cpp
void SpreadsheetCell::setValue(double value)
{
this->value = value;
}
```

a pointer to the object `this` is always passed to the method called.  `this` can be passed elsewhere, or used to disambiguate `value` above- which is both a data member and a function param.


```cpp

//declared as a stand alone function:
void printCell(const SpreadsheetCell& cell)
{
   cout << cell.getString() << endl;
}

//in the object, pass a pointer to this.
void SpreadsheetCell::setValue(double value)
{
   this->value = value;
   printCell(*this);
}
```

!!!Warning Warning: When passing `this` elsewhere, make sure you pass the pointer `*this`.

      ALSO: Instead of writing a printCell() function, it would be more convenient
       to overload the << operator, as explained in Chapter 15. You can then use 
       the following line to print a SpreadsheetCell: 
            
               cout << *this << endl;

---
### instantiation

---
#### Stack instantiation:
---


Space is reserved as soon as declared.  e.g. line 1.  Stack objects are destroyed as soon as they go out of scope (`{ }`).  This is why they don't need to be deleted.

```cpp
SpreadsheetCell myCell, anotherCell;
myCell.setValue(6);
anotherCell.setString("3.2");
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;
```
These you can access methods and public data members with the access dot `.` operator. 

On the stack, assuming a constructor that takes an int:: `SpreadsheetCell::SpreadsheetCell(int n);` you can call it by just putting the params in the descriptor.

`SpreadsheetCell myCell(5), anotherCell (4);`


!!!Warning You cannot explicitly call the Constructor, also when creating an object on the stack, omit parentheses for the default constructor.
      ```cpp
      SpreadsheetCell myCell.SpreadsheetCell(5)
      ```

      or call it later:

      ```cpp
      SpreadsheetCell myCell;
      myCell.SpreadsheetCell(5);

      ```

      Also, for default constructors, this looks right:

      ```cpp
      SpreadsheetCell myCell(); // WRONG, but will compile.
      myCell.setValue(6); //wont fail until <-here
      //it must be like this:
      SpreadsheetCell myCell;
      ```
      Do not use parens () when calling the default.  
      
      This problem is commonly known as *the most vexing parse,* and it means that your compiler thinks the first line is actually a function declaration for a function with the name myCell that takes zero arguments and returns a SpreadsheetCell object.







---
#### Heap Instantiation
---

Heap objects are not destroyed when they go out of scope.  If the pointer to it is declared in a scope and that scope closes, you lose the pointer, and thus access to the object which causes a memory leak.  Use smart pointers or use delete and nullptr.

Below space is not reserved until `new` or `make_unique` is called.  e.g. if you split the declaration and assignment below- you would have an indeterminate pointer which is bad, but also no space reserved.

```cpp
SpreadsheetCell* myCellp = new SpreadsheetCell();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
" " << myCellp->getString() << endl;
delete myCellp;
myCellp = nullptr;
```

Objects on the heap need to be referenced with the **arrow** operator `->` which combines dereference `*` and member access `.`

You can use this other way instead like this `(*myCellp).getValue()` for `myCellp->getValue()`

Must call `delete` on these (and not required but good practice to set that pointer to nullptr- as delete follows the pointer to the object.  Once its gone, the pointer still points there.), or use smart pointers:


```cpp
//C++11 style
unique_ptr<SpreadsheetCell> myCellP{make_unique<SpreadsheetCell>()}
//C++14 style
auto myCellp = make_unique<SpreadsheetCell>();
//<C++11 requires raw pointers.
SpreadsheeCell* myCellp = new SpreadsheetCell();

// Equivalent to:
// unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() <<
" " << myCellp->getString() << endl;
```

These all are similar

```cpp
//preC++11
SpreadsheetCell* myCellp = new SpreadsheetCell();
//AND
delete myCellp;
myCellp = nullptr;

//OR (C++14+)
auto myCellp = make_unique<SpreadsheetCell>();
//OR (C++11+)
unique_ptr<SpreadsheetCell> myCellp(new SpreadsheetCell());
```

Using Heap constructors:

```cpp
//C++14+
auto smartCellp = make_unique<SpreadsheetCell>(4);

// Or with raw pointers, without smart pointers (not recommended)
SpreadsheetCell* myCellp = new SpreadsheetCell(5);
SpreadsheetCell* anotherCellp = nullptr;  //if not used immed. make `nullptr`
anotherCellp = new SpreadsheetCell(4);

//after
delete myCellp; myCellp = nullptr; 
delete anotherCellp; anotherCellp = nullptr;

//default constrictor is same as the first example.
//Requires C++14+
auto smartCellp = make_unique<SpreadsheetCell>();
// Or with a raw pointer (not recommended)
//used pre-C++11
SpreadsheetCell* myCellp = new SpreadsheetCell();
```

generally: 

for C++ 14+

`auto [varName] = make_unique<[Class]> ( [ctor params] );`

for C++11+

`unique_ptr< [Class] > [varName] (new [Class]( [ctor params] ));`

for < C++ 11

`[Class]* [varName] = new [Class]( [ctor params] )`


## Error Handling 


```cpp
EvenSequence(initializer_list<double> args)
{
if (args.size() % 2 != 0) {
throw invalid_argument("initializer_list should "
"contain even number of elements.");
}
mSequence.assign(args);
}
//EvenSequence objects can be constructed as follows:
EvenSequence p1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
p1.dump();
try {
EvenSequence p2 = {1.0, 2.0, 3.0};
} catch (const invalid_argument& e) {
cout << e.what() << endl;
}
```



## IO Operations

```cpp

#include <iosteam.h>
cout << "HELLO WORLD"
cin>>readVal

```


___

## Setup (VS Code)
___
___

### Keybindings

```json
  {
    "key": "ctrl+alt+d z",
    "command": "editor.action.insertSnippet",
    "when": "editorTextFocus && editorLangId == 'cpp'",
    "args": {
      "name": "Debug2",
      "langId": "cpp",
      // "snippet": "helloo"
    }
  },
  {
    "key": "ctrl+alt+d x",
    "command": "editor.action.insertSnippet",
    "when": "editorTextFocus && editorLangId == 'cpp'",
    "args": {
      "name": "Debug NoLevel",
      "langId": "cpp",
      // "snippet": "helloo"
    }
  },
```

### Shortcuts

### Snippets

```json
	"Debug NoLevel": {
		"prefix": "dbg",
		"body": "if (DEBUG_EN) Serial.println(\"$1\");\n$0",
		"description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
	},
	"Debug": {
		"prefix": "dbglvl",
		"body": [
			"if (DEBUG_EN >= ${1: 1 , 2 , 3 , 4 } ) Serial.println(\"$2\");",
			"$0"
		],
		"description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
	},
	"Debug2": {
		"prefix": "dbgdet",
		"body": [
			"if (DEBUG_EN) Serial.println(\"${1:$TM_CURRENT_WORD}, $TM_LINE_NUMBER:$TM_FILENAME = \" + $1);",
			"$0"
		],
		"description": "Enter a statement to print to the console.  Expects DEBUG_EN define, with 0 disabled"
	}
}
```

### Settings

```json

```
