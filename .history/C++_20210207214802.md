# C ++ class

## Links

[Reference](https://en.cppreference.com/w/)


## Standard Libraries

- [Language Support
   - <cstddef>
   - <cstdlib>
   - <version>
   - <limits>
   - <climits>
   - <cfloat>
   - <cstdint>
   - <new>
   - <typeinfo>
   - <source_location>
   - <exception>
   - <initializer_list>
   - <compare>
   - <coroutine>
   - <csignal>
   - <csetjmp>
   - <cstdarg>
- Concepts
   - <concepts>
- Diagnostics
   - <stdexcept>
   - <cassert>
   - <cerrno>
   - <system_error>
- General utilities
   - <utility>
   - <memory>
   - <memory_resource>
   - <scoped_allocator>
   - <bitset>
   - <tuple>
   - <optional>
   - <any>
   - <variant>
   - <type_traits>
   - <ratio>
   - <chrono>
   - <typeindex>
   - <functional>
   - <stacktrace>
   - <ctime>
- Strings
   - <string>
   - <string_view>
   - <cstring>
   - <charconv>
   - <format>
   - <cctype>
   - <cwctype>
   - <cwchar>
   - <cuchar>
- Localization
   - <locale>
   - <codecvt>
   - <clocale>
- Containers
   - <span>
   - <array>
   - <vector>
   - <deque>
   - <forward_list>
   - <list>
   - <map>
   - <set>
   - <queue>
   - <unordered_map>
   - <unordered_set>
   - <stack>
- Iterators
   - <iterator>
- Ranges
   - <ranges>
- Algorithms
   - <algorithm>
   - <execution>
- Numerics
   - <complex>
   - <random>
   - <valarray>
   - <numeric>
   - <bit>
   - <numbers>
   - <cfenv>
   - <cmath>
- Input/Output
   - <iosfwd>
   - <ios>
   - <iomanip>
   - <streambuf>
   - <istream>
   - <ostream>
   - <iostream>
   - <sstream>
   - <fstream>
   - <syncstream>
   - <cstdio>
   - <cinttypes>
   - <strstream>
- Regular expressions
   - <regex>
- Filesystem support
   - <filesystem>
- Thread support
   - <thread>
   - <atomic>
   - <mutex>
   - <shared_mutex>
   - <condition_variable>
   - <future>
   - <stop_token>
   - <semaphore>
   - <latch>
   - <barrier>
- C compatibility
   - <ciso646>
   - <cstdalign>
   - <cstdbool>
   - <ccomplex>
   - <ctgmath>
   - <stdatomic.h>



## Archetypical Program


```cpp
// this is a format
#include <iostream>

/* Another comment format */

using namespace std;

int main(){
    cout << "Groovy Baby!" << "\n";
    
    return 0;
    }

int main()
{
	int x;		// This is a C++ style comment

	// Each comment line is preceded by slashes
	// This is another comment line

	/* C++ also supports C-Style comments */

	return 0;
}

```

header files no longer contain *.h

```cpp
#include <cstdlib>	// was <stdlib.h>
#include <cstring>	// was <string.h>
                      // char* functions from C
#include <string>     // C++ string class
```


## Reserved Keywords

//42



## C++ Operators

You can also just use keywords instead of chars to make more readable program

| Operator    | Operator Keyword | Description                     |
| ----------- | ---------------- | ------------------------------- |
| Logical    |                  |                                 |
| &&          | and              | logical AND                     |
| \|\|        | or               | logical OR                      |
| !           | not              | logical NOT                     |
| Inequality |                  |                                 |
| !=          | not_eq           | inequality                      |
| Bitwise    |                  |                                 |
| &           | bitand           | bitwise AND                     |
| \|          | bitor            | bitwise OR                      |
| ^           | xor              | bitwise exclusive OR            |
| ~           | compl            | bitwise complement              |
| Bitwise Op  |                  |                                 |
| &=          | and_eq           | bitwise AND assignment          |
| \|=         | or_eq            | bitwise inclusive OR assignment |
| ^=          | xor_eq           | bitwise exclusive OR assignment |


```cpp
// Program to demonstrate "and" operator keyword
//
// Some compilers require inclusion of special header files

#include	<iostream>
#include	<iso646.h>		// Required for Visual C++ 6.0
using namespace std;

int main()
{
	int x = 8;
	int y;

	cout << "Enter an integer: ";
	cin >> y;

	if ( (x > 0) && (y > 0) )   cout << "Both greater than 0 \n";

	if ( (x > 0) and (y > 0 ) ) cout << "Same thing \n";

	return 0;
}
```

### Operator Precedence

[Operator Pref](http://en.cppreference.com/w/cpp/language/operator_precedence)


## Stdin and Std Out

`<<` insertion operator 
`>>` extraction operator

These can be chained.

C++ uses the standard input stream cin and the standard output stream cout

`#include <cstdlib>`
`#include <iostream>`


An example of stdin and out vs. C.

```cpp
#include	<iostream>	// Header file defining standard C++ I/O 
#include	<stdio.h>		// Old C language header now deprecated
using namespace std;
int main()
{
	int x = 0;

	/* The old C way */

	printf( “Please enter an integer: “ );
	scanf( “%d”, &x );
	printf( “You entered %d \n”, x );

	// The C++ way

	cout << “Please enter an integer: “;
	cin >> x;
	cout << “You entered “ << x << endl;
	cout << “x plus 2 is “;
	cout << x + 2 << endl;
	
	return 0;
}
```

```cpp
// Program Input:	10	20
//		30
//
// Program Output:	You entered: 10 20 30

#include	<iostream>
using namespace std;
int main()
{
	int x, y, z;

	cout << "enter 3 integers: ";
	cin >> x >> y >> z;		// whitespace delimits numeric input objects

	cout << "You entered: " << x << " " << y << " " << z << endl;

	return 0;
}
```

### Stream Manipulators

`#include <iomanip>`

Stream manipulators may be parameterized or non-parameterized
Must include the header file iomanip to use parameterized manipulators

showpoint
noshowpoint
setw(n)
boolalpha
setprecision(3) 
scientific
fixed


```cpp
#include	<iostream>
#include	<iomanip>		// Required for parameterized manipulators
#define	dbln	"\n\n”	// Symbolic constant prints 2 newlines

using	namespace	std;

int main()
{
	float v = 2.19512567f;
	float c = 4.f;
	
	cout << v << endl;
	cout << c << dbln;

	cout << showpoint << v << endl;	// showpoint forces dec & 0’s
	cout << c << dbln;

	cout << noshowpoint << c << dbln;	// reinstate default

	cout << setw(10) << v << endl;	// set field width to 10
	cout << c << dbln;

	return 0;
}

// Program to illustrate stream manipulators
//
// Program Output:	2.19513
//		4
//
//		2.19513
//		4.00000
//
//		4
//
//		   2.19513
//		4



#include	<iostream>
#include	<iomanip>
#define	dbln	"\n\n"
using	namespace	std;

int main()
{
	bool	b = true;
	float	f = 3.14159f;

	cout << b << endl;
	cout << boolalpha << b << dbln;

	cout << f << endl;
	cout << scientific << setprecision(3) << f << endl;
	cout << fixed << f << dbln;

	return 0;
}

// Program to demonstrate stream manipulators
//
// Program Output:	1
//		true
//
//		3.14159
//		3.142e+000
//		3.142
```

## Types


character	
char	
Used to hold a single character of information.  Always requires a single byte of storage.

integer	
int	
Used to hold a signed whole number quantity.

short integer	
short	
Used to hold a signed whole number quantity.  Typically only requires half the storage requirements of a signed integer.

long integer	
long	
Used to hold a signed whole number quantity.  Typically requires twice as much storage as a normal signed integer.

unsigned integer	
unsigned	
Used to hold non-negative whole number quantities.

floating point	
float	
Used to hold signed numbers with fractional components.


double precision	
double	Used to hold signed numbers with fractional components.  Typically requires twice the storage as a float.


extended precision
	
long double	
Extended precision for floating point types.  Implemented as part of ISO/ANSI standard.

boolean
	
bool	
Used to hold literal values true and false.

constant	
const	
Used to hold a constant value that cannot be changed during program execution.



long long integer	
long long	
Range is at least the same as long, but varies with compiler.

unsigned long long integer	
unsigned long long	
Extended range unsigned integer.

16-bit character	
char16_t	
A single 16-bit character.


32-bit character	
char32_t	
A single 32-bit character.


automatic	
auto	
The compiler will decide the type automatically.


decltype	
decltype( expr )	
The compiler determines the type of the expression expr. Useful for use with templates.


bool types can be used to create state variables that indicate truth or falsity
bool variables can be assigned the literal values true and false
The default value of a bool type is false

### Type Inference & Alternative Function Syntax 

C++ 11

Compiler deduces type at compile time

`auto` keyword.

```cpp
auto x = 99; 		

auto value = myFunc();


// Alternative Function Syntax … most useful when using
// templates


//function myfunc takes an int and returns an int, using below.  

//is this a lambda
auto myFunc( int x ) -> int
{
	return 2*x;
}


// Ask the compiler to figure out return type … most useful
// when using templates

auto myFunc( float v1, float v2 )
{
	return v1 * v2;
}

```

## enums

```cpp
enum PieceType(PieceTypeKing, PieceTypeQueen, PieceTypeRook);
```

Creates an enum, just carries the numerical int value of position. 
You can also specify values-


```cpp
enum PieceType(PieceTypeKing = 2, PieceTypeQueen, PieceTypeRook=10, PieceTypeKnight);
```

The values following will just be incremented.  e.g. King = 2, Q=3 R=10, K=11.

## Strongly Typed Enums

The above always has the value given underneath.  This allows you (perhaps inappropriately) to compare two unrelated *enums*.

To prevent that- use strongly typed ones.

this is the type safe version.


```cpp
enum class PieceType
{
   King=1,
   Queen,
   Rook,
   Pawn
};
```

For an enum class, the enumeration value names are not automatically exported to the enclosing scope, which means that you always have to use the scope resolution operator:


`PieceType piece = PieceType::King;`

These do not have underlying integer values, assigning numbers like above is an error.

`if(PieceType::Queen==1){} //error`


```cpp
enum class PieceType : unsigned long
{
   King = 1,
   Queen,
   Rook = 10,
   Pawn
};
```

## Structs

Binds types into a new type. 

```cpp
struct Car{

   int year;
   int miles;
   std::string make;
}
```

You declare a car by just defining it: `Car car;`

Then access each value with the `.` operator.

### typedef

Using `typedef` on a `struct` defines it for external linkage.


`typedef struct { /* ... */ } S;`

## Control

- Iteration constructs
   - for
   - while
   - do-while
   - 'enhanced' for (C++ 11)
- Decision constructs
   - if-else
   - switch
   - conditional
- Other constructs
   - goto
   - break - used with switch.
   - continue - can be high risk

!!! question continue - said hed make a comment if used.

## Variables

- Variable names must begin with a letter or an underscore…remaining characters in a may be letters, digits or underscores
   - Avoid beginning names with single or double underscores
- Upper & lowercase letters are distinct
- All characters in a variable name are significant
- Must be declared, can be anywhere.

```cpp
#include	<iostream>
using namespace std;
int main()
{
	int a;		// value of a is undefined
	int b = 10;
	cout << b << endl;
	int z = 99;	// can’t do this in C language, but OK in C++
	cout << z << endl;

	for( int j = 0; j < 3; j++ )		// scope of j is for loop
	{
		cout << “j is “ << j << endl;
	}

	return 0;
}
```

### Initialization

Using bracket assignment- it will warn about truncation.

eg `int x = 3.14` - x = 3

```cpp
int hamburgers = {16};	// set hamburgers to 16
int hotdogs {3};		// set hotdogs to 3
int mustard {};		// set mustard to 0
int relish = {};		// set relish to 0
int ketchup(1);		// set ketchup to 1

long double x = 3.14159;
int a{x}, b = {x};		// truncation error
int c(x), d = x;		// ok – but will truncate.  Using these assingment methods wont have checking.
int a =3;
int b{3};
int c = {3};
int d(3);
```

Uniform initialization (using `{}`) calls the default initializer for each item.  Especially for `0` initialization.  Primitive int and non float chars are 0, all floating pt values 0.0, and pointer values are `nullptr`

It prevents narrowing.

```cpp
void func(int i){/* */}

int x = 3.14 //auto narrows to 3.
func(3.14); //passes 3 automatically
//these may result in a compiler error for narrowing.

int x{3.14} //error
int x = {3.14} //error
func{(3.14)} //error

```

### List Initialization

There is a difference with Copy `=` and Direct Initilization in C++17

#### Direct List Initialization

`T obj {arg1, arg2, ...}`

```cpp
auto a {11}; //int

auto b {11, 22}; //Error - no list one element allowed
```

#### Copy List Initialization

`T obj = {arg1, arg2, ...}`

```cpp
auto a = {11}; //initilizer list<int>

auto b = {11, 22}; //initilizer list<int>
auto c = {11, 22.2} //ERROR must be same type.
```

### Scoping

`static` keyword- allocates memory in .data segment at compile time, is loaded at execution and remains in memory for the duration.

//to do week 2

`inline` 

`extern` - used to declare an object without defining it.  States that it is defined elsewhere in the Linkage units- e.g. in another file.

      `extern int n;` - ok 
      `extern int n = 0;` not ok.

      To define you need:

      `extern const int n = 0`
#### namespaces



## Constants

- Literal constants are values that appear in a program (e.g. 33, 12.99, ‘A’, “Hello”)
- Literal constants are not addressable - Can’t directly address memory where value is stored
- Every literal constant has an associated type

Literal integer constants are treated as signed values of type int


      34		// decimal notation
      036		// octal
      0x14		// hexadecimal
      128L		// long (could also use l )
      128U		// unsigned (could also use u )
      14UL		// long unsigned
      14LL		// long long*
      128ULL		// unsigned long long*
      3.14159F	// float (could also use f )
      0.0		// double (default type)
      7.435L		// extended precision
      4e2		// scientific notation 
      2.35E-2	// scientific notation

f = F = float.

Printable literal character constants written with character inside single quotes


      ‘G’		// letter G
      ‘,’		// literal comma
      ‘ ‘		// literal blank
      ‘5’		// literal 5

Nonprintable characters, the single & double quote marks, and the backslash are represented using escape sequences

      \n		// newline
      \b	// backspace
      \t		// horizontal tab		
      \v	// vertical tab
      \r		// carriage return	
      \f	// formfeed
      \a		// alert (bell)		
      \\	// backslash
      \’		// single quote		
      \”	// double quote

Can also use \xxx where xxx is a sequence of up to 3 octal digits

		\0	// null			
      \7	// bell
		\14	// newline		
      \062	// ‘2’


Can be used to transform a variable into an addressable constant
Must be initialized in its declaration


const float pi = 3.14159;	// pi is a constant
const int c;		// ERROR!! must be initialized in declaration
pi = 22.3;		// ERROR!! can’t change value


### String Literals

String literals consist of zero or more characters enclosed in double quotes. Compiler adds terminating null character
Treated as an array of constant (const) characters
Nonprintable characters are represented by their escape sequences
		“”			// null string
		“A”			// not same as char literal ‘A’
		“Hello”		// String literal
		“Hello \t World”	// Embedded escape sequence
		“Multiple line \	// Can extend for several lines
		literal”		// using a backslash as the 
					// last character on a line

### Boolean literals

      true, false


## Complex Types


arrays, structures (type struct), unions (type union), and enumerators (type enum) are legacy types from C
C++ structures can have functions as well as data types as members
The class type will be discussed later in this course


### array

An  Array name is a special pointer, its a fixed pointer.  You can add to the array.

`
int[] array = {1...4}
`pos = array + 1;`

However you cannot reassign the array or start of the array.

`array +=1; //error`

### structure

You define struct names at the end:

```cpp
   #include <string>

    typedef struct {
        string valueName;
        long long value;
    } values;
```


### class

### union

### enumerator


47-84, 114-134

## Strings

endl

//38
//39


Using a string manipulator

```cpp
//40
// Program to read and display a line of input
//
// Program Input:	That’s better
//
// Program Output:	You entered: That’s better

#include	<iostream>
using namespace std;
int main()
{
	char line[81];
	char c;
	int i = 0;

	cin >> noskipws;		// use manipulator to recognize whitespace

	cout << "Please enter a line of text: ";

	while ( ( cin >> c ) && ( c != '\n' ) )
		line[i++] = c;

	line[i] = '\0';

	cout << "\n\nYou entered: " << line << endl;
	return 0;
}
```

## Mixing Input Types

//41

## Functions

- Two basic types of functions
   - Ordinary functions --- like in C
   - Class member functions --- used in O-O programs
- A function definition (i.e., its code) or a function prototype must appear in the code before the function is invoked
- Normal practice is to use function prototypes
- Functions may have arguments & may return a value

//46

Functions need to appear before they are used, so a protoype has to occur.

```cpp
#include	<iostream>
using namespace std;


//function prototypes
void print_message();		// A function prototype
float product( int , float ); // Another prototype

			void main()
			{
				float k = 13.54f;
				float num = 43.77f;

				print_message();		// Invoking functions
				cout << product( k , num );
			}

			// Function definitions

void print_message()
			{
				cout << "Where's the Beef?" << " \n";
			}

			float product ( int c , float f )
			{
				return ( c * f );
			}
```

Typically placed at top of source file or “included” via a pre-processor directive

When placed outside of a function scope is from point of placement to end of source file

When placed inside a function scope is from point of placement to end of function

```cpp

#include	<iostream>
using namespace std;

void myfunc();		// Scope is source file
void message();

void main()
{
	message();
	myfunc();
}

void myfunc()
{
	int afunc();	// Scope is myfunc()

	message();
	cout << afunc();
}

int afunc() { return 99; }

void message() { cout << “HELLO \n”; }

```

### Passing Arguments and Returning

//49

//50

### Using const With Function Arguments

If a value passed as a function argument should not be altered in the function, the argument should be declared as `const`

The C++ compiler will not allow const arguments to be modified by a function


```cpp
// Function taking const argument

void myfunc( int arg1, const int arg2 )
{
	arg1 = 2*arg1;		// OK
	arg2 += arg1;		// ERROR --- can’t change arg2
}
```

## Classes


### Brief assignment

   `CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}`
   

### Uniform Initialization

Structs and classes can be initiated similarly

```cpp

stuct CircleStruct{
   int x,y ;
   double radius;
}
class CircleClass{
   public:
   CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius){}

}
CircleStruct myCircle = {10, 10, 2.5}
CircleStruct myCircle4{10, 10, 2.5}
CircleClass myCircle2{10, 10, 2.5};
CircleClass myCircle3 = {10, 10, 2.5};

